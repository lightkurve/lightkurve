
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>lightkurve.lightcurve &#8212; Lightkurve </title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-69171-9', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../../index.html">
<p class="title">Lightkurve v2.5</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../whats-new-v2.html">
  What's new?
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../quickstart.html">
  Quickstart
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../tutorials/index.html">
  Tutorials
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../reference/index.html">
  API
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../about/index.html">
  About Lightkurve
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../development/index.html">
  Developing for Lightkurve
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/lightkurve/lightkurve" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for lightkurve.lightcurve</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Defines LightCurve, KeplerLightCurve, and TessLightCurve.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">savgol_filter</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">MaskedColumn</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span>
<span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">TimeBase</span><span class="p">,</span> <span class="n">Time</span><span class="p">,</span> <span class="n">TimeDelta</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">astropy.units</span> <span class="kn">import</span> <span class="n">Quantity</span>
<span class="kn">from</span> <span class="nn">astropy.timeseries</span> <span class="kn">import</span> <span class="n">TimeSeries</span><span class="p">,</span> <span class="n">aggregate_downsample</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">vstack</span>
<span class="kn">from</span> <span class="nn">astropy.stats</span> <span class="kn">import</span> <span class="n">calculate_bin_edges</span>
<span class="kn">from</span> <span class="nn">astropy.utils.decorators</span> <span class="kn">import</span> <span class="n">deprecated</span><span class="p">,</span> <span class="n">deprecated_renamed_argument</span>
<span class="kn">from</span> <span class="nn">astropy.utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>
<span class="kn">from</span> <span class="nn">astropy.utils.masked</span> <span class="kn">import</span> <span class="n">Masked</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">PACKAGEDIR</span><span class="p">,</span> <span class="n">MPLSTYLE</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">running_mean</span><span class="p">,</span>
    <span class="n">bkjd_to_astropy_time</span><span class="p">,</span>
    <span class="n">btjd_to_astropy_time</span><span class="p">,</span>
    <span class="n">validate_method</span><span class="p">,</span>
    <span class="n">_query_solar_system_objects</span><span class="p">,</span>
    <span class="n">finalize_notebook_url</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">LightkurveWarning</span><span class="p">,</span> <span class="n">LightkurveDeprecationWarning</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;LightCurve&quot;</span><span class="p">,</span> <span class="s2">&quot;KeplerLightCurve&quot;</span><span class="p">,</span> <span class="s2">&quot;TessLightCurve&quot;</span><span class="p">,</span> <span class="s2">&quot;FoldedLightCurve&quot;</span><span class="p">]</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">_HAS_VAR_BINS</span> <span class="o">=</span> <span class="s1">&#39;time_bin_end&#39;</span> <span class="ow">in</span> <span class="n">aggregate_downsample</span><span class="o">.</span><span class="vm">__kwdefaults__</span>

<span class="k">def</span> <span class="nf">_to_unitless_day</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">_to_unitless_day</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_is_dict_like</span><span class="p">(</span><span class="n">data1</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="s2">&quot;keys&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="s2">&quot;keys&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_is_list_like</span><span class="p">(</span><span class="n">data1</span><span class="p">):</span>
    <span class="c1"># https://stackoverflow.com/a/37842328</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_np_structured_array</span><span class="p">(</span><span class="n">data1</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>


<div class="viewcode-block" id="LightCurve"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.html#lightkurve.LightCurve">[docs]</a><span class="k">class</span> <span class="nc">LightCurve</span><span class="p">(</span><span class="n">TimeSeries</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclass of AstroPy `~astropy.table.Table` guaranteed to have *time*, *flux*, and *flux_err* columns.</span>

<span class="sd">    Compared to the generic `~astropy.timeseries.TimeSeries` class, `LightCurve`</span>
<span class="sd">    ensures that each object has `time`, `flux`, and `flux_err` columns.</span>
<span class="sd">    These three columns are special for two reasons:</span>
<span class="sd">    1. they are the key columns upon which all light curve operations operate;</span>
<span class="sd">    2. they are always present (though they may be populated with ``NaN`` values).</span>

<span class="sd">    `LightCurve` objects also provide user-friendly attribute access to</span>
<span class="sd">    columns and meta data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy ndarray, dict, list, `~astropy.table.Table`, or table-like object, optional</span>
<span class="sd">        Data to initialize time series. This does not need to contain the times</span>
<span class="sd">        or fluxes, which can be provided separately, but if it does contain the</span>
<span class="sd">        times and fluxes they should be in columns called ``&#39;time&#39;``,</span>
<span class="sd">        ``&#39;flux&#39;``, and ``&#39;flux_err&#39;`` to be automatically recognized.</span>
<span class="sd">    time : `~astropy.time.Time` or iterable</span>
<span class="sd">        Time values.  They can either be given directly as a</span>
<span class="sd">        `~astropy.time.Time` array or as any iterable that initializes the</span>
<span class="sd">        `~astropy.time.Time` class.</span>
<span class="sd">    flux : `~astropy.units.Quantity` or iterable</span>
<span class="sd">        Flux values for every time point.</span>
<span class="sd">    flux_err : `~astropy.units.Quantity` or iterable</span>
<span class="sd">        Uncertainty on each flux data point.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Additional keyword arguments are passed to `~astropy.table.QTable`.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    meta : `dict`</span>
<span class="sd">        meta data associated with the lightcurve. The header of the underlying FITS file (if applicable)</span>
<span class="sd">        is store in this dictionary. By convention, keys in this dictionary are usually in uppercase.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    *Attribute access*: You can access a column or a ``meta`` value directly as an attribute.</span>

<span class="sd">    &gt;&gt;&gt; lc.flux    # shortcut for lc[&#39;flux&#39;]   # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; lc.sector  # shortcut for lc.meta[&#39;SECTOR&#39;]   # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; lc.flux = lc.flux * 1.05  # update the values of a column.   # doctest: +SKIP</span>

<span class="sd">    In case the given name is both a column name and a key in ``meta``, the column will be returned.</span>

<span class="sd">    Note that you *cannot* create a new column using the attribute interface. If you do so,</span>
<span class="sd">    a new attribute is created instead, and a warning is raised.</span>

<span class="sd">    If you do create such attributes on purpose, please note that the attributes are not carried</span>
<span class="sd">    over when the lightcurve object is copied, or a new lightcurve object is derived</span>
<span class="sd">    based on a copy, e.g., ``normalize()``.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import lightkurve as lk</span>
<span class="sd">    &gt;&gt;&gt; lc = lk.LightCurve(time=[1, 2, 3, 4], flux=[0.98, 1.02, 1.03, 0.97])</span>
<span class="sd">    &gt;&gt;&gt; lc.time</span>
<span class="sd">    &lt;Time object: scale=&#39;tdb&#39; format=&#39;jd&#39; value=[1. 2. 3. 4.]&gt;</span>
<span class="sd">    &gt;&gt;&gt; lc.flux</span>
<span class="sd">    &lt;Quantity [0.98, 1.02, 1.03, 0.97]&gt;</span>
<span class="sd">    &gt;&gt;&gt; lc.bin(time_bin_size=2, time_bin_start=0.5).flux</span>
<span class="sd">    &lt;Quantity [1., 1.]&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># The constructor of the `TimeSeries` base class will enforce the presence</span>
    <span class="c1"># of these columns:</span>
    <span class="n">_required_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;flux&quot;</span><span class="p">,</span> <span class="s2">&quot;flux_err&quot;</span><span class="p">]</span>

    <span class="c1"># The following keywords were removed in Lightkurve v2.0.</span>
    <span class="c1"># Their use will trigger a warning.</span>
    <span class="n">_deprecated_keywords</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;targetid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time_format&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time_scale&quot;</span><span class="p">,</span>
        <span class="s2">&quot;flux_unit&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_deprecated_column_keywords</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;centroid_col&quot;</span><span class="p">,</span>
        <span class="s2">&quot;centroid_row&quot;</span><span class="p">,</span>
        <span class="s2">&quot;cadenceno&quot;</span><span class="p">,</span>
        <span class="s2">&quot;quality&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># If an iterable is passed for ``time``, we will initialize an AstroPy</span>
    <span class="c1"># ``Time`` object using the following format and scale:</span>
    <span class="n">_default_time_format</span> <span class="o">=</span> <span class="s2">&quot;jd&quot;</span>
    <span class="n">_default_time_scale</span> <span class="o">=</span> <span class="s2">&quot;tdb&quot;</span>

    <span class="c1"># To emulate pandas, we do not support creating new columns or meta data</span>
    <span class="c1"># fields via attribute assignment, and raise a warning in __setattr__ when</span>
    <span class="c1"># a new attribute is created.  We need to relax this warning during the</span>
    <span class="c1"># initial construction of the object using `_new_attributes_relax`.</span>
    <span class="n">_new_attributes_relax</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># cf. issue #925</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">100_000</span>

<div class="viewcode-block" id="LightCurve.__init__"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.html#lightkurve.LightCurve.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flux_err</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># the ` {has,get,set}_time_in_data()`: helpers to handle `data` of different types</span>
        <span class="c1"># in some cases, they also need to access kwargs[&quot;names&quot;] as well</span>

        <span class="k">def</span> <span class="nf">get_time_idx_in</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="n">time_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">time_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">get_time_in_data_list</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;names&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># the first item MUST be time if no names specified</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TimeBase</span><span class="p">):</span>  <span class="c1"># Time or TimeDelta</span>
                    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time_idx</span> <span class="o">=</span> <span class="n">get_time_idx_in</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">time_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">time_idx</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">set_time_in_data_list</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;data should be non-empty&quot;</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;names&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># the first item MUST be time if no names specified</span>
                <span class="c1"># this is to support base Table&#39;s select columns</span>
                <span class="c1"># in __getitem__()</span>
                <span class="c1"># https://github.com/astropy/astropy/blob/326435449ad8d859f1abf36800c3fb88d49c27ea/astropy/table/table.py#L1888</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time_idx</span> <span class="o">=</span> <span class="n">get_time_idx_in</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">time_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">time_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;data should have time column&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_time_in_data_np_structured_array</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># no labeled filed, not a structured array</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">remove_time_from_data_np_structured_array</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;data should be a numpy structured array&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;data should have a time field&quot;</span><span class="p">)</span>
            <span class="n">filtered_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="s2">&quot;time&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">filtered_names</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">has_time_in_data</span><span class="p">():</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Check if the data has a column with the name&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">_is_dict_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># data is a dict-like object with keys</span>
                <span class="k">return</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">_is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># case data is a list-like object (a list of columns, etc.)</span>
                <span class="k">return</span> <span class="n">get_time_in_data_list</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">_is_np_structured_array</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># case numpy structured array (supported by base TimeSeries)</span>
                <span class="c1"># https://numpy.org/doc/stable/user/basics.rec.html</span>
                <span class="k">return</span> <span class="n">get_time_in_data_np_structured_array</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported type for time in data: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_time_in_data</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">_is_dict_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># data is a dict-like object with keys</span>
                <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">_is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">get_time_in_data_list</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">_is_np_structured_array</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">get_time_in_data_np_structured_array</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># should never reach here. It&#39;d have been caught by `has_time_in()``</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unsupported type for time in data&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">set_time_in_data</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_is_dict_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># data is a dict-like object with keys</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">_is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">set_time_in_data_list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_is_np_structured_array</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c1"># astropy Time cannot be assigned to a column in np structured array</span>
                <span class="c1"># we have special codepath handling it outside this function</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Setting Time instances to np structured array is not supported&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># should never reach here. It&#39;d have been caught by `has_time_in()``</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Unsupported type for time in data&quot;</span><span class="p">)</span>

        <span class="c1"># Delay checking for required columns until the end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_columns_relax</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Lightkurve v1.x supported passing time, flux, and flux_err as</span>
        <span class="c1"># positional arguments. We support it here for backwards compatibility.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;passing flux as a positional argument is deprecated&quot;</span>
                <span class="s2">&quot;, please use ``flux=...`` instead.&quot;</span><span class="p">,</span>
                <span class="n">LightkurveDeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">flux_err</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># For backwards compatibility with Lightkurve v1.x,</span>
        <span class="c1"># we support passing deprecated keywords via **kwargs.</span>
        <span class="n">deprecated_kws</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecated_keywords</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">deprecated_kws</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>

        <span class="n">deprecated_column_kws</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecated_column_keywords</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">deprecated_column_kws</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>

        <span class="c1"># If `time` is passed as keyword argument, we populate it with integer numbers</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">has_time_in_data</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
            <span class="c1"># We are tolerant of missing time format</span>
            <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">(</span><span class="n">Time</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">)):</span>
                <span class="c1"># Lightkurve v1.x supported specifying the time_format</span>
                <span class="c1"># as a constructor kwarg</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span>
                    <span class="n">time</span><span class="p">,</span>
                    <span class="nb">format</span><span class="o">=</span><span class="n">deprecated_kws</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;time_format&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_time_format</span><span class="p">),</span>
                    <span class="n">scale</span><span class="o">=</span><span class="n">deprecated_kws</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;time_scale&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_time_scale</span><span class="p">),</span>
                <span class="p">)</span>

        <span class="c1"># Also be tolerant of missing time format if time is passed via `data`</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">has_time_in_data</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">get_time_in_data</span><span class="p">(),</span> <span class="p">(</span><span class="n">Time</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">)):</span>
                <span class="n">tmp_time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span>
                    <span class="n">get_time_in_data</span><span class="p">(),</span>
                    <span class="nb">format</span><span class="o">=</span><span class="n">deprecated_kws</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;time_format&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_time_format</span><span class="p">),</span>
                    <span class="n">scale</span><span class="o">=</span><span class="n">deprecated_kws</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;time_scale&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_time_scale</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">_is_np_structured_array</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="c1"># special case for np structured array</span>
                    <span class="c1"># one cannot set a `Time` instance to it</span>
                    <span class="c1"># so we set the time to the `time` param, and take it out of data</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">tmp_time</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">remove_time_from_data_np_structured_array</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">set_time_in_data</span><span class="p">(</span><span class="n">tmp_time</span><span class="p">)</span>

        <span class="c1"># Allow overriding the required columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_columns</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_required_columns&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_required_columns</span><span class="p">)</span>

        <span class="c1"># Call the SampledTimeSeries constructor.</span>
        <span class="c1"># Disable required columns for now; we&#39;ll check those later.</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_required_columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_columns</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># For some operations, an empty time series needs to be created, then</span>
        <span class="c1"># columns added one by one. We should check that when columns are added</span>
        <span class="c1"># manually, time is added first and is of the right type.</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flux_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_required_columns_relax</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>

        <span class="c1"># Load `time`, `flux`, and `flux_err` from the table as local variable names</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>  <span class="c1"># super().__init__() guarantees this is a column</span>
        <span class="k">if</span> <span class="s2">&quot;flux&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;flux&#39; has been given both in the `data` table and as a keyword argument&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;flux_err&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flux_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">flux_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;flux_err&#39; has been given both in the `data` table and as a keyword argument&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Ensure `flux` and `flux_err` are populated with NaNs if missing</span>
        <span class="k">if</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
            <span class="n">flux</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">deprecated_kws</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;flux_unit&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">flux_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flux_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">))</span>
            <span class="n">flux_err</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux_err</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="n">flux_err</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">flux_err</span><span class="p">,</span> <span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="c1"># Backwards compatibility with Lightkurve v1.x</span>
        <span class="c1"># Ensure attributes are set if passed via deprecated kwargs</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">deprecated_kws</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="n">kw</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">=</span> <span class="n">deprecated_kws</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>

        <span class="c1"># Ensure all required columns are in the right order</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delay_required_column_checks</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_required_columns</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">colnames</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="nb">locals</span><span class="p">()[</span><span class="n">col</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Ensure columns are set if passed via deprecated kwargs</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">deprecated_column_kws</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span> <span class="ow">and</span> <span class="n">kw</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">deprecated_column_kws</span><span class="p">[</span><span class="n">kw</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">kw</span><span class="p">)</span>

        <span class="c1"># Ensure flux and flux_err have the same units</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;flux and flux_err must have the same units&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_new_attributes_relax</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_columns_relax</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_columns</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expose all columns and meta keywords as attributes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;_meta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_meta&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_meta&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_meta&quot;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_meta&quot;</span><span class="p">][</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;object has no attribute </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;To get copied, attributes have to be stored in the meta dictionary!&quot;&quot;&quot;</span>
        <span class="n">to_set_as_attr</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">to_set_as_attr</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># astropy will convert value to Time if needed</span>
        <span class="k">elif</span> <span class="p">(</span><span class="s2">&quot;columns&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replace_column</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;_meta&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_meta&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_meta&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_meta&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_meta&quot;</span><span class="p">][</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_set_as_attr</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_set_as_attr</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">to_set_as_attr</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_attributes_relax</span>
                <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;meta&#39;</span>
            <span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Lightkurve doesn&#39;t allow columns or meta values to be created via a new attribute name.&quot;</span>
                        <span class="s2">&quot;A new attribute is created. It will not be carried over when the object is copied.&quot;</span>
                        <span class="s2">&quot; - see https://docs.lightkurve.org/reference/api/lightkurve.LightCurve.html&quot;</span>
                    <span class="p">),</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_simple_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a simple __repr__.</span>

<span class="sd">        Used by `LightCurveCollection`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;LABEL&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; LABEL=</span><span class="se">\&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LABEL&#39;</span><span class="p">)</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;QUARTER&quot;</span><span class="p">,</span> <span class="s2">&quot;CAMPAIGN&quot;</span><span class="p">,</span> <span class="s2">&quot;SECTOR&quot;</span><span class="p">,</span> <span class="s2">&quot;AUTHOR&quot;</span><span class="p">,</span> <span class="s2">&quot;FLUX_ORIGIN&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">kw</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;&gt;&quot;</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_base_repr_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">descr_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Defines the description shown by `__repr__` and `_html_repr_`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">descr_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">descr_vals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">masked</span><span class="p">:</span>
                <span class="n">descr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;masked=True&quot;</span><span class="p">)</span>
            <span class="n">descr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;length=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="k">if</span> <span class="s2">&quot;LABEL&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
                <span class="n">descr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LABEL=</span><span class="se">\&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LABEL&#39;</span><span class="p">)</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;QUARTER&quot;</span><span class="p">,</span> <span class="s2">&quot;CAMPAIGN&quot;</span><span class="p">,</span> <span class="s2">&quot;SECTOR&quot;</span><span class="p">,</span> <span class="s2">&quot;AUTHOR&quot;</span><span class="p">,</span> <span class="s2">&quot;FLUX_ORIGIN&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">:</span>
                    <span class="n">descr_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">kw</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_base_repr_</span><span class="p">(</span><span class="n">html</span><span class="o">=</span><span class="n">html</span><span class="p">,</span> <span class="n">descr_vals</span><span class="o">=</span><span class="n">descr_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Define `time`, `flux`, `flux_err` as class attributes to enable IDE</span>
    <span class="c1"># of these required columns auto-completion.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Time</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Time values stored as an AstroPy `~astropy.time.Time` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>

    <span class="nd">@time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flux</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quantity</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Brightness values stored as an AstroPy `~astropy.units.Quantity` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span>

    <span class="nd">@flux</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flux_err</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quantity</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Brightness uncertainties stored as an AstroPy `~astropy.units.Quantity` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span>

    <span class="nd">@flux_err</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">flux_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_err</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_err</span>

<div class="viewcode-block" id="LightCurve.select_flux"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.select_flux.html#lightkurve.LightCurve.select_flux">[docs]</a>    <span class="k">def</span> <span class="nf">select_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_column</span><span class="p">,</span> <span class="n">flux_err_column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign a different column to be the flux column.</span>

<span class="sd">        This method returns a copy of the LightCurve in which the ``flux``</span>
<span class="sd">        and ``flux_err`` columns have been replaced by the values contained</span>
<span class="sd">        in a different column.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flux_column : str</span>
<span class="sd">            Name of the column that should become the &#39;flux&#39; column.</span>
<span class="sd">        flux_err_column : str or `None`</span>
<span class="sd">            Name of the column that should become the &#39;flux_err&#39; column.</span>
<span class="sd">            By default, the column will be used that is obtained by adding the</span>
<span class="sd">            suffix &quot;_err&quot; to the value of ``flux_column``.  If such a</span>
<span class="sd">            column does not exist, ``flux_err`` will be populated with NaN values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc : LightCurve</span>
<span class="sd">            Copy of the ``LightCurve`` object with the new flux values assigned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        You can use this function to change the flux data on which most Lightkurve</span>
<span class="sd">        features operate.  For example, to view a periodogram based on the &quot;sap_flux&quot;</span>
<span class="sd">        column in a TESS light curve, use::</span>

<span class="sd">            &gt;&gt;&gt; lc.select_flux(&quot;sap_flux&quot;).to_periodogram(&quot;lombscargle&quot;).plot()  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Input validation</span>
        <span class="k">if</span> <span class="n">flux_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">flux_column</span><span class="si">}</span><span class="s2">&#39; is not a column&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flux_err_column</span> <span class="ow">and</span> <span class="n">flux_err_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">flux_err_column</span><span class="si">}</span><span class="s2">&#39; is not a column&quot;</span><span class="p">)</span>

        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span><span class="p">[</span><span class="n">flux_column</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">flux_err_column</span><span class="p">:</span>  <span class="c1"># not None</span>
            <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span><span class="p">[</span><span class="n">flux_err_column</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if `flux_err_column` is unspecified, we attempt to use</span>
            <span class="c1"># f&quot;{flux_column}_err&quot; if it exists</span>
            <span class="n">flux_err_column</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">flux_column</span><span class="si">}</span><span class="s2">_err&quot;</span>
            <span class="k">if</span> <span class="n">flux_err_column</span> <span class="ow">in</span> <span class="n">lc</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span><span class="p">[</span><span class="n">flux_err_column</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;FLUX_ORIGIN&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_column</span>
        <span class="n">normalized_new_flux</span> <span class="o">=</span> <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>
        <span class="c1"># Note: here we assume unitless flux means it&#39;s normalized</span>
        <span class="c1"># it&#39;s not exactly true in many constructed lightcurves in unit test</span>
        <span class="c1"># but the assumption should hold for any real world use cases, e.g. TESS QLP</span>
        <span class="k">if</span> <span class="n">normalized_new_flux</span><span class="p">:</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;NORMALIZED&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalized_new_flux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># remove it altogether.</span>
            <span class="c1"># Setting to False would suffice;</span>
            <span class="c1"># but in typical non-normalized LC, the header will not be there at all.</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;NORMALIZED&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lc</span></div>

    <span class="c1"># Define deprecated attributes for compatibility with Lightkurve v1.x:</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;time.format&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">time_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;time.scale&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">time_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">scale</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">astropy_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;flux.unit&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">flux_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;flux&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">flux_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;2.0&quot;</span><span class="p">,</span>
        <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;fits.open(lc.filename)&quot;</span><span class="p">,</span>
        <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">SAP_FLUX</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A copy of the light curve in which `lc.flux = lc.sap_flux`</span>
<span class="sd">        and `lc.flux_err = lc.sap_flux_err`.  It is provided for backwards-</span>
<span class="sd">        compatibility with Lightkurve v1.x and will be removed soon.&quot;&quot;&quot;</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;sap_flux&quot;</span><span class="p">]</span>
        <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;sap_flux_err&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lc</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">PDCSAP_FLUX</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A copy of the light curve in which `lc.flux = lc.pdcsap_flux`</span>
<span class="sd">        and `lc.flux_err = lc.pdcsap_flux_err`.  It is provided for backwards-</span>
<span class="sd">        compatibility with Lightkurve v1.x and will be removed soon.&quot;&quot;&quot;</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;pdcsap_flux&quot;</span><span class="p">]</span>
        <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lc</span><span class="p">[</span><span class="s2">&quot;pdcsap_flux_err&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">lc</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">newlc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LightCurve</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot add LightCurve objects because &quot;</span>
                    <span class="s2">&quot;they do not have equal length (</span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">).&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Two LightCurve objects with inconsistent time &quot;</span>
                    <span class="s2">&quot;values are being added.&quot;</span><span class="p">,</span>
                    <span class="n">LightkurveWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">flux</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">flux_err</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">+</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">newlc</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">newlc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LightCurve</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot multiply LightCurve objects because &quot;</span>
                    <span class="s2">&quot;they do not have equal length (</span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">).&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Two LightCurve objects with inconsistent time &quot;</span>
                    <span class="s2">&quot;values are being multiplied.&quot;</span><span class="p">,</span>
                    <span class="n">LightkurveWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">flux</span>
            <span class="c1"># Applying standard uncertainty propagation, cf.</span>
            <span class="c1"># https://en.wikipedia.org/wiki/Propagation_of_uncertainty#Example_formulae</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">newlc</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">/</span> <span class="n">other</span><span class="o">.</span><span class="n">flux</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">UnitBase</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">FunctionUnitBase</span><span class="p">)</span>
        <span class="p">):</span>  <span class="c1"># cf. astropy/issues/6517</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span>
        <span class="k">return</span> <span class="n">newlc</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">newlc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LightCurve</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot divide LightCurve objects because &quot;</span>
                    <span class="s2">&quot;they do not have equal length (</span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">).&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Two LightCurve objects with inconsistent time &quot;</span>
                    <span class="s2">&quot;values are being divided.&quot;</span><span class="p">,</span>
                    <span class="n">LightkurveWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">flux</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">newlc</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">/</span> <span class="n">other</span><span class="o">.</span><span class="n">flux</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span>
            <span class="n">newlc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">newlc</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">show_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prints a description of all non-callable attributes.</span>

<span class="sd">        Prints in order of type (ints, strings, lists, arrays, others).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">deprecated_properties</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deprecated_keywords</span><span class="p">)</span>
        <span class="n">deprecated_properties</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="s2">&quot;flux_quantity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SAP_FLUX&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PDCSAP_FLUX&quot;</span><span class="p">,</span>
            <span class="s2">&quot;astropy_time&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hdu&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deprecated_properties</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;res&quot;</span><span class="p">:</span> <span class="n">res</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;print&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;print&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;array </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;print&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list length </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;list&quot;</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;print&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;print&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;str&quot;</span>
                <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;wcs&quot;</span><span class="p">:</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;print&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;astropy.wcs.wcs.WCS&quot;</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;other&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;print&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
                    <span class="n">attrs</span><span class="p">[</span><span class="n">attr</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;other&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Attribute&quot;</span><span class="p">,</span> <span class="s2">&quot;Description&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="nb">object</span><span class="p">,</span> <span class="nb">object</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="s2">&quot;list&quot;</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span> <span class="s2">&quot;other&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">dic</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">dic</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">typ</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="n">attr</span><span class="p">,</span> <span class="n">dic</span><span class="p">[</span><span class="s2">&quot;print&quot;</span><span class="p">]])</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">output</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">max_lines</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_width</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="LightCurve.append"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.append.html#lightkurve.LightCurve.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">others</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append one or more other `LightCurve` object(s) to this one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        others : `LightCurve`, or list of `LightCurve`</span>
<span class="sd">            Light curve(s) to be appended to the current one.</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            If True, change the current `LightCurve` instance in place instead</span>
<span class="sd">            of creating and returning a new one. Defaults to False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_lc : `LightCurve`</span>
<span class="sd">            Light curve which has the other light curves appened to it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;the `inplace` parameter is no longer supported &quot;</span>
                <span class="s2">&quot;as of Lightkurve v2.0&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="n">others</span> <span class="o">=</span> <span class="p">(</span><span class="n">others</span><span class="p">,)</span>

        <span class="c1"># Re-use LightCurveCollection.stitch() to avoid code duplication</span>
        <span class="kn">from</span> <span class="nn">.collections</span> <span class="kn">import</span> <span class="n">LightCurveCollection</span>  <span class="c1"># avoid circular import</span>

        <span class="k">return</span> <span class="n">LightCurveCollection</span><span class="p">((</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">))</span><span class="o">.</span><span class="n">stitch</span><span class="p">(</span><span class="n">corrector_func</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.flatten"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.flatten.html#lightkurve.LightCurve.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">window_length</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span>
        <span class="n">polyorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">return_trend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">break_tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">niters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes the low frequency trend using scipy&#39;s Savitzky-Golay filter.</span>

<span class="sd">        This method wraps `scipy.signal.savgol_filter`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        window_length : int</span>
<span class="sd">            The length of the filter window (i.e. the number of coefficients).</span>
<span class="sd">            ``window_length`` must be a positive odd integer.</span>
<span class="sd">        polyorder : int</span>
<span class="sd">            The order of the polynomial used to fit the samples. ``polyorder``</span>
<span class="sd">            must be less than window_length.</span>
<span class="sd">        return_trend : bool</span>
<span class="sd">            If `True`, the method will return a tuple of two elements</span>
<span class="sd">            (flattened_lc, trend_lc) where trend_lc is the removed trend.</span>
<span class="sd">        break_tolerance : int</span>
<span class="sd">            If there are large gaps in time, flatten will split the flux into</span>
<span class="sd">            several sub-lightcurves and apply `savgol_filter` to each</span>
<span class="sd">            individually. A gap is defined as a period in time larger than</span>
<span class="sd">            `break_tolerance` times the median gap.  To disable this feature,</span>
<span class="sd">            set `break_tolerance` to None.</span>
<span class="sd">        niters : int</span>
<span class="sd">            Number of iterations to iteratively sigma clip and flatten. If more than one, will</span>
<span class="sd">            perform the flatten several times, removing outliers each time.</span>
<span class="sd">        sigma : int</span>
<span class="sd">            Number of sigma above which to remove outliers from the flatten</span>
<span class="sd">        mask : boolean array with length of self.time</span>
<span class="sd">            Boolean array to mask data with before flattening. Flux values where</span>
<span class="sd">            mask is True will not be used to flatten the data. An interpolated</span>
<span class="sd">            result will be provided for these points. Use this mask to remove</span>
<span class="sd">            data you want to preserve, e.g. transits.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `scipy.signal.savgol_filter`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flatten_lc : `LightCurve`</span>
<span class="sd">            New light curve object with long-term trends removed.</span>
<span class="sd">        If ``return_trend`` is set to ``True``, this method will also return:</span>
<span class="sd">        trend_lc : `LightCurve`</span>
<span class="sd">            New light curve object containing the trend that was removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Deep copy ensures we don&#39;t change the original.</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span>
        <span class="c1"># Add NaNs &amp; outliers to the mask</span>
        <span class="n">extra_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">extra_mask</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)))</span> <span class="o">&lt;=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="p">)</span>
        <span class="c1"># In astropy&gt;=5.0, extra_mask is a masked array</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">extra_mask</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">extra_mask</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># support astropy&lt;5.0</span>
            <span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">extra_mask</span>

        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">niters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">break_tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">break_tolerance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">polyorder</span> <span class="o">&gt;=</span> <span class="n">window_length</span><span class="p">:</span>
                <span class="n">polyorder</span> <span class="o">=</span> <span class="n">window_length</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;polyorder must be smaller than window_length, &quot;</span>
                    <span class="s2">&quot;using polyorder=</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">polyorder</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># Split the lightcurve into segments by finding large gaps in time</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>  <span class="c1"># Ignore warnings due to NaNs</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="n">break_tolerance</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">dt</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">cut</span><span class="p">)</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cut</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
            <span class="c1"># Then, apply the savgol_filter to each segment separately</span>
            <span class="n">trend_signal</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">mask</span><span class="p">])),</span> <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">):</span>
                <span class="c1"># Reduce `window_length` and `polyorder` for short segments;</span>
                <span class="c1"># this prevents `savgol_filter` from raising an exception</span>
                <span class="c1"># If the segment is too short, just take the median</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">window_length</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">l</span><span class="p">),</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">break_tolerance</span><span class="p">]):</span>
                    <span class="n">trend_signal</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="n">l</span><span class="p">:</span><span class="n">h</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Scipy outputs a warning here that is not useful, will be fixed in version 1.2</span>
                    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
                        <span class="n">trsig</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span>
                            <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="n">l</span><span class="p">:</span><span class="n">h</span><span class="p">],</span>
                            <span class="n">window_length</span><span class="o">=</span><span class="n">window_length</span><span class="p">,</span>
                            <span class="n">polyorder</span><span class="o">=</span><span class="n">polyorder</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">trend_signal</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">trsig</span><span class="p">,</span> <span class="n">trend_signal</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="c1"># Ignore outliers; note we add `1e-14` below to avoid detecting</span>
            <span class="c1"># outliers which are merely caused by numerical noise.</span>
            <span class="n">mask1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">trend_signal</span><span class="p">))</span> <span class="o">&lt;</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">trend_signal</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span>
                <span class="o">+</span> <span class="n">Quantity</span><span class="p">(</span><span class="mf">1e-14</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">mask</span><span class="p">][</span><span class="n">mask1</span><span class="p">],</span>
                <span class="n">trend_signal</span><span class="p">[</span><span class="n">mask1</span><span class="p">],</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">trend_signal</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
            <span class="c1"># In astropy&gt;=5.0, mask1 is a masked array</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask1</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># support astropy&lt;5.0</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">mask1</span>

        <span class="n">flatten_lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="c1"># ignore invalid division warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="n">flatten_lc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">flatten_lc</span><span class="o">.</span><span class="n">flux</span> <span class="o">/</span> <span class="n">trend_signal</span>
            <span class="n">flatten_lc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="n">flatten_lc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">/</span> <span class="n">trend_signal</span>

        <span class="n">flatten_lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;NORMALIZED&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">return_trend</span><span class="p">:</span>
            <span class="n">trend_lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">trend_lc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">trend_signal</span>
            <span class="k">return</span> <span class="n">flatten_lc</span><span class="p">,</span> <span class="n">trend_lc</span>
        <span class="k">return</span> <span class="n">flatten_lc</span></div>

<div class="viewcode-block" id="LightCurve.fold"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.fold.html#lightkurve.LightCurve.fold">[docs]</a>    <span class="nd">@deprecated_renamed_argument</span><span class="p">(</span>
        <span class="s2">&quot;transit_midpoint&quot;</span><span class="p">,</span>
        <span class="s2">&quot;epoch_time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2.0&quot;</span><span class="p">,</span>
        <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@deprecated_renamed_argument</span><span class="p">(</span>
        <span class="s2">&quot;t0&quot;</span><span class="p">,</span> <span class="s2">&quot;epoch_time&quot;</span><span class="p">,</span> <span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">fold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epoch_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epoch_phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">wrap_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a `FoldedLightCurve` object folded on a period and epoch.</span>

<span class="sd">        This method is identical to AstroPy&#39;s `~astropy.timeseries.TimeSeries.fold()`</span>
<span class="sd">        method, except it returns a `FoldedLightCurve` object which offers</span>
<span class="sd">        convenient plotting methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        period : float `~astropy.units.Quantity`</span>
<span class="sd">            The period to use for folding.  If a ``float`` is passed we&#39;ll</span>
<span class="sd">            assume it is in units of days.</span>
<span class="sd">        epoch_time : `~astropy.time.Time`</span>
<span class="sd">            The time to use as the reference epoch, at which the relative time</span>
<span class="sd">            offset / phase will be ``epoch_phase``. Defaults to the first time</span>
<span class="sd">            in the time series.</span>
<span class="sd">        epoch_phase : float or `~astropy.units.Quantity`</span>
<span class="sd">            Phase of ``epoch_time``. If ``normalize_phase`` is `True`, this</span>
<span class="sd">            should be a dimensionless value, while if ``normalize_phase`` is</span>
<span class="sd">            ``False``, this should be a `~astropy.units.Quantity` with time</span>
<span class="sd">            units. Defaults to 0.</span>
<span class="sd">        wrap_phase : float or `~astropy.units.Quantity`</span>
<span class="sd">            The value of the phase above which values are wrapped back by one</span>
<span class="sd">            period. If ``normalize_phase`` is `True`, this should be a</span>
<span class="sd">            dimensionless value, while if ``normalize_phase`` is ``False``,</span>
<span class="sd">            this should be a `~astropy.units.Quantity` with time units.</span>
<span class="sd">            Defaults to half the period, so that the resulting time series goes</span>
<span class="sd">            from ``-period / 2`` to ``period / 2`` (if ``normalize_phase`` is</span>
<span class="sd">            `False`) or -0.5 to 0.5 (if ``normalize_phase`` is `True`).</span>
<span class="sd">        normalize_phase : bool</span>
<span class="sd">            If `False` phase is returned as `~astropy.time.TimeDelta`,</span>
<span class="sd">            otherwise as a dimensionless `~astropy.units.Quantity`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        folded_lightcurve : `FoldedLightCurve`</span>
<span class="sd">            The folded light curve object in which the ``time`` column</span>
<span class="sd">            holds the phase values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lightkurve v1.x assumed that `period` was given in days if no unit</span>
        <span class="c1"># was specified. We maintain this behavior for backwards-compatibility.</span>
        <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="n">period</span> <span class="o">*=</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span>
        <span class="k">if</span> <span class="n">epoch_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epoch_time</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
            <span class="n">epoch_time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span>
                <span class="n">epoch_time</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">scale</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">epoch_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epoch_phase</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">normalize_phase</span>
        <span class="p">):</span>
            <span class="n">epoch_phase</span> <span class="o">*=</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span>
        <span class="k">if</span> <span class="n">wrap_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wrap_phase</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="n">wrap_phase</span> <span class="o">*=</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span>

        <span class="c1"># Warn if `epoch_time` appears to use the wrong format</span>
        <span class="k">if</span> <span class="n">epoch_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">epoch_time</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">2450000</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;bkjd&quot;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;`epoch_time` appears to be given in JD, &quot;</span>
                    <span class="s2">&quot;however the light curve time uses BKJD &quot;</span>
                    <span class="s2">&quot;(i.e. JD - 2454833).&quot;</span><span class="p">,</span>
                    <span class="n">LightkurveWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;btjd&quot;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;`epoch_time` appears to be given in JD, &quot;</span>
                    <span class="s2">&quot;however the light curve time uses BTJD &quot;</span>
                    <span class="s2">&quot;(i.e. JD - 2457000).&quot;</span><span class="p">,</span>
                    <span class="n">LightkurveWarning</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
            <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">,</span>
            <span class="n">epoch_time</span><span class="o">=</span><span class="n">epoch_time</span><span class="p">,</span>
            <span class="n">epoch_phase</span><span class="o">=</span><span class="n">epoch_phase</span><span class="p">,</span>
            <span class="n">wrap_phase</span><span class="o">=</span><span class="n">wrap_phase</span><span class="p">,</span>
            <span class="n">normalize_phase</span><span class="o">=</span><span class="n">normalize_phase</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># The folded time would pass the `TimeSeries` validation check if</span>
        <span class="c1"># `normalize_phase=True`, so creating a `FoldedLightCurve` object</span>
        <span class="c1"># requires the following three-step workaround:</span>
        <span class="c1"># 1. Give the folded light curve a valid time column again</span>
        <span class="k">with</span> <span class="n">ts</span><span class="o">.</span><span class="n">_delay_required_column_checks</span><span class="p">():</span>
            <span class="n">folded_time</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">remove_column</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 2. Create the folded object</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">FoldedLightCurve</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">ts</span><span class="p">)</span>
        <span class="c1"># 3. Restore the folded time</span>
        <span class="k">with</span> <span class="n">lc</span><span class="o">.</span><span class="n">_delay_required_column_checks</span><span class="p">():</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">remove_column</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">folded_time</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Add extra column and meta data specific to FoldedLightCurve</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;time_original&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_required_columns</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;PERIOD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">period</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;EPOCH_TIME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">epoch_time</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;EPOCH_PHASE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">epoch_phase</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;WRAP_PHASE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrap_phase</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;NORMALIZE_PHASE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalize_phase</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lc</span></div>

<div class="viewcode-block" id="LightCurve.normalize"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.normalize.html#lightkurve.LightCurve.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;unscaled&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a normalized version of the light curve.</span>

<span class="sd">        The normalized light curve is obtained by dividing the ``flux`` and</span>
<span class="sd">        ``flux_err`` object attributes by the median flux.</span>
<span class="sd">        Optionally, the result will be multiplied by 1e2 (if `unit=&#39;percent&#39;`),</span>
<span class="sd">        1e3 (`unit=&#39;ppt&#39;`), or 1e6 (`unit=&#39;ppm&#39;`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : &#39;unscaled&#39;, &#39;percent&#39;, &#39;ppt&#39;, &#39;ppm&#39;</span>
<span class="sd">            The desired relative units of the normalized light curve;</span>
<span class="sd">            &#39;ppt&#39; means &#39;parts per thousand&#39;, &#39;ppm&#39; means &#39;parts per million&#39;.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">            &gt;&gt;&gt; import lightkurve as lk</span>
<span class="sd">            &gt;&gt;&gt; lc = lk.LightCurve(time=[1, 2, 3], flux=[25945.7, 25901.5, 25931.2], flux_err=[6.8, 4.6, 6.2])</span>
<span class="sd">            &gt;&gt;&gt; normalized_lc = lc.normalize()</span>
<span class="sd">            &gt;&gt;&gt; normalized_lc.flux</span>
<span class="sd">            &lt;Quantity [1.00055917, 0.99885466, 1.        ]&gt;</span>
<span class="sd">            &gt;&gt;&gt; normalized_lc.flux_err</span>
<span class="sd">            &lt;Quantity [0.00026223, 0.00017739, 0.00023909]&gt;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        normalized_lightcurve : `LightCurve`</span>
<span class="sd">            A new light curve object in which ``flux`` and ``flux_err`` have</span>
<span class="sd">            been divided by the median flux.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        LightkurveWarning</span>
<span class="sd">            If the median flux is negative or within half a standard deviation</span>
<span class="sd">            from zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_method</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;unscaled&quot;</span><span class="p">,</span> <span class="s2">&quot;percent&quot;</span><span class="p">,</span> <span class="s2">&quot;ppt&quot;</span><span class="p">,</span> <span class="s2">&quot;ppm&quot;</span><span class="p">])</span>
        <span class="n">median_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">std_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>

        <span class="c1"># If the median flux is within half a standard deviation from zero, the</span>
        <span class="c1"># light curve is likely zero-centered and normalization makes no sense.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">median_flux</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">std_flux</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">median_flux</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">std_flux</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The light curve appears to be zero-centered &quot;</span>
                <span class="s2">&quot;(median=</span><span class="si">{:.2e}</span><span class="s2"> +/- </span><span class="si">{:.2e}</span><span class="s2">); `normalize()` will divide &quot;</span>
                <span class="s2">&quot;the light curve by a value close to zero, which is &quot;</span>
                <span class="s2">&quot;probably not what you want.&quot;</span>
                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">median_flux</span><span class="p">,</span> <span class="n">std_flux</span><span class="p">),</span>
                <span class="n">LightkurveWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># If the median flux is negative, normalization will invert the light</span>
        <span class="c1"># curve and makes no sense.</span>
        <span class="k">if</span> <span class="n">median_flux</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The light curve has a negative median flux (</span><span class="si">{:.2e}</span><span class="s2">);&quot;</span>
                <span class="s2">&quot; `normalize()` will therefore divide by a negative &quot;</span>
                <span class="s2">&quot;number and invert the light curve, which is probably&quot;</span>
                <span class="s2">&quot;not what you want&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">median_flux</span><span class="p">),</span>
                <span class="n">LightkurveWarning</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Create a new light curve instance and normalize its values</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux</span> <span class="o">/</span> <span class="n">median_flux</span>
        <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">/</span> <span class="n">median_flux</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">flux</span> <span class="o">*=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">*=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>

        <span class="c1"># Set the desired relative (dimensionless) units</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;percent&quot;</span><span class="p">:</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">percent</span><span class="p">)</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">percent</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;ppt&quot;</span><span class="p">,</span> <span class="s2">&quot;ppm&quot;</span><span class="p">):</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">flux</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>

        <span class="n">lc</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;NORMALIZED&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">lc</span></div>

<div class="viewcode-block" id="LightCurve.remove_nans"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.remove_nans.html#lightkurve.LightCurve.remove_nans">[docs]</a>    <span class="k">def</span> <span class="nf">remove_nans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;flux&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes cadences where ``column`` is a NaN.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column : str</span>
<span class="sd">            Column to check for NaNs.  Defaults to ``&#39;flux&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clean_lightcurve : `LightCurve`</span>
<span class="sd">            A new light curve object from which NaNs fluxes have been removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">            &gt;&gt;&gt; import lightkurve as lk</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; lc = lk.LightCurve({&#39;time&#39;: [1, 2, 3], &#39;flux&#39;: [1., np.nan, 1.]})</span>
<span class="sd">            &gt;&gt;&gt; lc.remove_nans()</span>
<span class="sd">            &lt;LightCurve length=2&gt;</span>
<span class="sd">            time   flux  flux_err</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            Time float64 float64</span>
<span class="sd">            ---- ------- --------</span>
<span class="sd">            1.0     1.0      nan</span>
<span class="sd">            3.0     1.0      nan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">column</span><span class="p">])]</span>  <span class="c1"># This will return a sliced copy</span></div>

<div class="viewcode-block" id="LightCurve.fill_gaps"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.fill_gaps.html#lightkurve.LightCurve.fill_gaps">[docs]</a>    <span class="k">def</span> <span class="nf">fill_gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gaussian_noise&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fill in gaps in time.</span>

<span class="sd">        By default, the gaps will be filled with random white Gaussian noise</span>
<span class="sd">        distributed according to</span>
<span class="sd">        :math:`\mathcal{N} (\mu=\overline{\mathrm{flux}}, \sigma=\mathrm{CDPP})`.</span>
<span class="sd">        No other methods are supported at this time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string {&#39;gaussian_noise&#39;}</span>
<span class="sd">            Method to use for gap filling. Fills with Gaussian noise by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled_lightcurve : `LightCurve`</span>
<span class="sd">            A new light curve object in which all NaN values and gaps in time</span>
<span class="sd">            have been filled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">remove_nans</span><span class="p">()</span>
        <span class="c1"># nlc = lc.copy()</span>
        <span class="n">newdata</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Find missing time points</span>
        <span class="c1"># Most precise method, taking into account time variation due to orbit</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="s2">&quot;cadenceno&quot;</span><span class="p">):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">))</span> <span class="o">*</span> <span class="n">lc</span><span class="o">.</span><span class="n">cadenceno</span><span class="o">.</span><span class="n">value</span>
            <span class="n">ncad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">cadenceno</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lc</span><span class="o">.</span><span class="n">cadenceno</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">in_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">ncad</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">cadenceno</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">ncad</span> <span class="o">=</span> <span class="n">ncad</span><span class="p">[</span><span class="o">~</span><span class="n">in_original</span><span class="p">]</span>
            <span class="n">ndt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">ncad</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">cadenceno</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

            <span class="n">ncad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ncad</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">cadenceno</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">ndt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">ncad</span><span class="p">,</span> <span class="n">ndt</span> <span class="o">=</span> <span class="n">ncad</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ncad</span><span class="p">)],</span> <span class="n">ndt</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ncad</span><span class="p">)]</span>
            <span class="n">ntime</span> <span class="o">=</span> <span class="n">ndt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">))</span> <span class="o">*</span> <span class="n">ncad</span>
            <span class="n">newdata</span><span class="p">[</span><span class="s2">&quot;cadenceno&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncad</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Less precise method</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">::]</span> <span class="o">-</span> <span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">ntime</span> <span class="o">=</span> <span class="p">[</span><span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">::]:</span>
                <span class="n">prevtime</span> <span class="o">=</span> <span class="n">ntime</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">prevtime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">dt</span><span class="p">:</span>
                    <span class="n">ntime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prevtime</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
                    <span class="n">prevtime</span> <span class="o">=</span> <span class="n">ntime</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ntime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">ntime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="n">in_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Fill in time points</span>
        <span class="n">newdata</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">ntime</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ntime</span><span class="p">))</span>
        <span class="n">f</span><span class="p">[</span><span class="n">in_original</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">fe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ntime</span><span class="p">))</span>
        <span class="n">fe</span><span class="p">[</span><span class="n">in_original</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span><span class="p">)</span>

        <span class="c1"># Temporary workaround for issue #1172.  TODO: remove the `if`` statement</span>
        <span class="c1"># below once we adopt AstroPy &gt;=5.0.3 as a minimum dependency.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
            <span class="n">fe</span><span class="p">[</span><span class="o">~</span><span class="n">in_original</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">ntime</span><span class="p">[</span><span class="o">~</span><span class="n">in_original</span><span class="p">],</span> <span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span><span class="o">.</span><span class="n">unmasked</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fe</span><span class="p">[</span><span class="o">~</span><span class="n">in_original</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">ntime</span><span class="p">[</span><span class="o">~</span><span class="n">in_original</span><span class="p">],</span> <span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;gaussian_noise&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">estimate_cdpp</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="o">~</span><span class="n">in_original</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">std</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="n">in_original</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No such method as </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>

        <span class="n">newdata</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">newdata</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="n">fe</span><span class="p">,</span> <span class="n">lc</span><span class="o">.</span><span class="n">flux_err</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="s2">&quot;quality&quot;</span><span class="p">):</span>
            <span class="n">quality</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ntime</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">lc</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">quality</span><span class="p">[</span><span class="n">in_original</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lc</span><span class="o">.</span><span class="n">quality</span><span class="p">)</span>
            <span class="n">quality</span><span class="p">[</span><span class="o">~</span><span class="n">in_original</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">65536</span>
            <span class="n">newdata</span><span class="p">[</span><span class="s2">&quot;quality&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quality</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # TODO: add support for other columns</span>
<span class="sd">        for column in lc.columns:</span>
<span class="sd">            if column in (&quot;time&quot;, &quot;flux&quot;, &quot;flux_err&quot;, &quot;quality&quot;):</span>
<span class="sd">                continue</span>
<span class="sd">            old_values = lc[column]</span>
<span class="sd">            new_values = np.empty(len(ntime), dtype=old_values.dtype)</span>
<span class="sd">            new_values[~in_original] = np.nan</span>
<span class="sd">            new_values[in_original] = np.copy(old_values)</span>
<span class="sd">            newdata[column] = new_values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LightCurve</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">newdata</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.remove_outliers"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.remove_outliers.html#lightkurve.LightCurve.remove_outliers">[docs]</a>    <span class="k">def</span> <span class="nf">remove_outliers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">sigma_lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma_upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes outlier data points using sigma-clipping.</span>

<span class="sd">        This method returns a new `LightCurve` object from which data points</span>
<span class="sd">        are removed if their flux values are greater or smaller than the median</span>
<span class="sd">        flux by at least ``sigma`` times the standard deviation.</span>

<span class="sd">        Sigma-clipping works by iterating over data points, each time rejecting</span>
<span class="sd">        values that are discrepant by more than a specified number of standard</span>
<span class="sd">        deviations from a center value. If the data contains invalid values</span>
<span class="sd">        (NaNs or infs), they are automatically masked before performing the</span>
<span class="sd">        sigma clipping.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This function is a convenience wrapper around</span>
<span class="sd">            `astropy.stats.sigma_clip()` and provides the same functionality.</span>
<span class="sd">            Any extra arguments passed to this method will be passed on to</span>
<span class="sd">            ``sigma_clip``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma : float</span>
<span class="sd">            The number of standard deviations to use for both the lower and</span>
<span class="sd">            upper clipping limit. These limits are overridden by</span>
<span class="sd">            ``sigma_lower`` and ``sigma_upper``, if input. Defaults to 5.</span>
<span class="sd">        sigma_lower : float or None</span>
<span class="sd">            The number of standard deviations to use as the lower bound for</span>
<span class="sd">            the clipping limit. Can be set to float(&#39;inf&#39;) in order to avoid</span>
<span class="sd">            clipping outliers below the median at all. If `None` then the</span>
<span class="sd">            value of ``sigma`` is used. Defaults to `None`.</span>
<span class="sd">        sigma_upper : float or None</span>
<span class="sd">            The number of standard deviations to use as the upper bound for</span>
<span class="sd">            the clipping limit. Can be set to float(&#39;inf&#39;) in order to avoid</span>
<span class="sd">            clipping outliers above the median at all. If `None` then the</span>
<span class="sd">            value of ``sigma`` is used. Defaults to `None`.</span>
<span class="sd">        return_mask : bool</span>
<span class="sd">            Whether or not to return a mask (i.e. a boolean array) indicating</span>
<span class="sd">            which data points were removed. Entries marked as `True` in the</span>
<span class="sd">            mask are considered outliers.  This mask is not returned by default.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `astropy.stats.sigma_clip`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clean_lc : `LightCurve`</span>
<span class="sd">            A new light curve object from which outlier data points have been</span>
<span class="sd">            removed.</span>
<span class="sd">        outlier_mask : NumPy array, optional</span>
<span class="sd">            Boolean array flagging which cadences were removed.</span>
<span class="sd">            Only returned if `return_mask=True`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This example generates a new light curve in which all points</span>
<span class="sd">        that are more than 1 standard deviation from the median are removed::</span>

<span class="sd">            &gt;&gt;&gt; lc = LightCurve(time=[1, 2, 3, 4, 5], flux=[1, 1000, 1, -1000, 1])</span>
<span class="sd">            &gt;&gt;&gt; lc_clean = lc.remove_outliers(sigma=1)</span>
<span class="sd">            &gt;&gt;&gt; lc_clean.time</span>
<span class="sd">            &lt;Time object: scale=&#39;tdb&#39; format=&#39;jd&#39; value=[1. 3. 5.]&gt;</span>
<span class="sd">            &gt;&gt;&gt; lc_clean.flux</span>
<span class="sd">            &lt;Quantity [1., 1., 1.]&gt;</span>

<span class="sd">        Instead of specifying `sigma`, you may specify separate `sigma_lower`</span>
<span class="sd">        and `sigma_upper` parameters to remove only outliers above or below</span>
<span class="sd">        the median. For example::</span>

<span class="sd">            &gt;&gt;&gt; lc = LightCurve(time=[1, 2, 3, 4, 5], flux=[1, 1000, 1, -1000, 1])</span>
<span class="sd">            &gt;&gt;&gt; lc_clean = lc.remove_outliers(sigma_lower=float(&#39;inf&#39;), sigma_upper=1)</span>
<span class="sd">            &gt;&gt;&gt; lc_clean.time</span>
<span class="sd">            &lt;Time object: scale=&#39;tdb&#39; format=&#39;jd&#39; value=[1. 3. 4. 5.]&gt;</span>
<span class="sd">            &gt;&gt;&gt; lc_clean.flux</span>
<span class="sd">            &lt;Quantity [    1.,     1., -1000.,     1.]&gt;</span>

<span class="sd">        Optionally, you may use the `return_mask` parameter to return a boolean</span>
<span class="sd">        array which flags the outliers identified by the method. For example::</span>

<span class="sd">            &gt;&gt;&gt; lc_clean, mask = lc.remove_outliers(sigma=1, return_mask=True)</span>
<span class="sd">            &gt;&gt;&gt; mask</span>
<span class="sd">            array([False,  True, False,  True, False])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The import time for `sigma_clip` is somehow very slow, so we use</span>
        <span class="c1"># a local import here.</span>
        <span class="kn">from</span> <span class="nn">astropy.stats.sigma_clipping</span> <span class="kn">import</span> <span class="n">sigma_clip</span>

        <span class="c1"># astropy.stats.sigma_clip won&#39;t work with masked ndarrays so we convert to regular arrays</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">Masked</span><span class="p">):</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># First, we create the outlier mask using AstroPy&#39;s sigma_clip function</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>  <span class="c1"># Ignore warnings due to NaNs or Infs</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">Masked</span><span class="p">):</span>
                <span class="c1"># Workaround for https://github.com/astropy/astropy/issues/14360</span>
                <span class="c1"># in passing MaskedQuantity to sigma_clip, by converting it to Quantity.</span>
                <span class="c1"># We explicitly fill masked values with `np.nan` here to ensure they are masked during sigma clipping.</span>
                <span class="c1"># To handle unlikely edge case, convert int to float to ensure filing `np.nan` work.</span>
                <span class="c1"># The conversion is acceptable because only the mask of the sigma_clip() result is used.</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">):</span>
                    <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">outlier_mask</span> <span class="o">=</span> <span class="n">sigma_clip</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">flux</span><span class="p">,</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
                <span class="n">sigma_lower</span><span class="o">=</span><span class="n">sigma_lower</span><span class="p">,</span>
                <span class="n">sigma_upper</span><span class="o">=</span><span class="n">sigma_upper</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">mask</span>
        <span class="c1"># Second, we return the masked light curve and optionally the mask itself</span>
        <span class="k">if</span> <span class="n">return_mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="o">~</span><span class="n">outlier_mask</span><span class="p">],</span> <span class="n">outlier_mask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="o">~</span><span class="n">outlier_mask</span><span class="p">]</span></div>

<div class="viewcode-block" id="LightCurve.bin"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.bin.html#lightkurve.LightCurve.bin">[docs]</a>    <span class="nd">@deprecated_renamed_argument</span><span class="p">(</span>
        <span class="s2">&quot;binsize&quot;</span><span class="p">,</span>
        <span class="n">new_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">since</span><span class="o">=</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span>
        <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span><span class="p">,</span>
        <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;time_bin_size&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">bin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time_bin_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time_bin_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time_bin_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aggregate_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">binsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bins a lightcurve in equally-spaced bins in time.</span>

<span class="sd">        If the original light curve contains flux uncertainties (``flux_err``),</span>
<span class="sd">        the binned lightcurve will report the root-mean-square error.</span>
<span class="sd">        If no uncertainties are included, the binned curve will return the</span>
<span class="sd">        standard deviation of the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_bin_size : `~astropy.units.Quantity` or `~astropy.time.TimeDelta`, optional</span>
<span class="sd">            The time interval for the binned time series - this is either a scalar</span>
<span class="sd">            value (in which case all time bins will be assumed to have the same</span>
<span class="sd">            duration) or as an array of values (in which case each time bin can</span>
<span class="sd">            have a different duration). If this argument is provided,</span>
<span class="sd">            ``time_bin_end`` should not be provided.</span>
<span class="sd">            (Default: 0.5 days; default unit: days.)</span>
<span class="sd">        time_bin_start : `~astropy.time.Time` or iterable, optional</span>
<span class="sd">            The start time for the binned time series - this can be either given</span>
<span class="sd">            directly as a `~astropy.time.Time` array or as any iterable that</span>
<span class="sd">            initializes the `~astropy.time.Time` class. This can also be a scalar</span>
<span class="sd">            value if ``time_bin_size`` is provided. Defaults to the first</span>
<span class="sd">            time in the sampled time series.</span>
<span class="sd">        time_bin_end : `~astropy.time.Time` or iterable, optional</span>
<span class="sd">            The times of the end of each bin - this can be either given directly as</span>
<span class="sd">            a `~astropy.time.Time` array or as any iterable that initializes the</span>
<span class="sd">            `~astropy.time.Time` class. This can only be given if ``time_bin_start``</span>
<span class="sd">            is an array of values. If ``time_bin_end`` is a scalar, time bins are</span>
<span class="sd">            assumed to be contiguous, such that the end of each bin is the start</span>
<span class="sd">            of the next one, and ``time_bin_end`` gives the end time for the last</span>
<span class="sd">            bin. If ``time_bin_end`` is an array, the time bins do not need to be</span>
<span class="sd">            contiguous. If this argument is provided, ``time_bin_size`` should not</span>
<span class="sd">            be provided. This option, like the iterable form of ``time_bin_start``,</span>
<span class="sd">            requires Astropy 5.0.</span>
<span class="sd">        n_bins : int, optional</span>
<span class="sd">            The number of bins to use. Defaults to the number needed to fit all</span>
<span class="sd">            the original points. Note that this will create this number of bins</span>
<span class="sd">            of length ``time_bin_size`` independent of the lightkurve length.</span>
<span class="sd">        aggregate_func : callable, optional</span>
<span class="sd">            The function to use for combining points in the same bin. Defaults</span>
<span class="sd">            to np.nanmean.</span>
<span class="sd">        bins : int, iterable or str, optional</span>
<span class="sd">            If an int, this gives the number of bins to divide the lightkurve into.</span>
<span class="sd">            In contrast to ``n_bins`` this adjusts the length of ``time_bin_size``</span>
<span class="sd">            to accommodate the input time series length.</span>
<span class="sd">            If it is an iterable of ints, it specifies the indices of the bin edges.</span>
<span class="sd">            If a string, it must be one of  &#39;blocks&#39;, &#39;knuth&#39;, &#39;scott&#39; or &#39;freedman&#39;</span>
<span class="sd">            defining a method of automatically determining an optimal bin size.</span>
<span class="sd">            See `~astropy.stats.histogram` for a description of each method.</span>
<span class="sd">            Note that &#39;blocks&#39; is not a useful method for regularly sampled data.</span>
<span class="sd">        binsize : int</span>
<span class="sd">            In Lightkurve v1.x, the default behavior of `bin()` was to create</span>
<span class="sd">            bins which contained an equal number data points in each bin.</span>
<span class="sd">            This type of binning is discouraged because it usually makes more sense to</span>
<span class="sd">            create equally-sized bins in time duration, which is the new default</span>
<span class="sd">            behavior in Lightkurve v2.x.  Nevertheless, this `binsize` parameter</span>
<span class="sd">            allows users to simulate the old behavior of Lightkurve v1.x.</span>
<span class="sd">            For ease of implementation, setting this parameter is identical to passing</span>
<span class="sd">            ``time_bin_size = lc.time[binsize] - time[0]``, which means that</span>
<span class="sd">            the bins are not guaranteed to contain an identical number of</span>
<span class="sd">            data points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        binned_lc : `LightCurve`</span>
<span class="sd">            A new light curve which has been binned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">binsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only one of ``bins`` and ``binsize`` can be specified.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">binsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">time_bin_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;``bins`` or ``binsize`` conflicts with &quot;</span>
                <span class="s2">&quot;``n_bins`` or ``time_bin_size``.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bins</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;blocks&#39;</span><span class="p">,</span> <span class="s1">&#39;knuth&#39;</span><span class="p">,</span> <span class="s1">&#39;scott&#39;</span><span class="p">,</span> <span class="s1">&#39;freedman&#39;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;``bins`` must have integer type.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_HAS_VAR_BINS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sequence or method for ``bins`` requires Astropy 5.0.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_bin_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_bin_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_bin_start</span><span class="p">,</span> <span class="p">(</span><span class="n">Time</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">):</span>
                <span class="n">time_bin_start</span> <span class="o">=</span> <span class="n">TimeDelta</span><span class="p">(</span>
                    <span class="n">time_bin_start</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">scale</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time_bin_start</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span>
                    <span class="n">time_bin_start</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">scale</span>
                <span class="p">)</span>

        <span class="c1"># Backwards compatibility with Lightkurve v1.x</span>
        <span class="k">if</span> <span class="n">time_bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">_HAS_VAR_BINS</span><span class="p">:</span>
                    <span class="c1"># This actually calculates equal-length bins just as the method below;</span>
                    <span class="c1"># should it instead set equal-number bins with binsize=int(len(self) / bins)?</span>
                    <span class="c1"># Get start times in mjd and convert back to original format</span>
                    <span class="n">bin_starts</span> <span class="o">=</span> <span class="n">calculate_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">mjd</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">time_bin_start</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">Time</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;mjd&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;&quot;classic&quot; `bins` require Astropy 5.0; will use constant lengths in time.&#39;</span><span class="p">,</span>
                        <span class="n">LightkurveWarning</span><span class="p">)</span>
                    <span class="c1"># Odd memory error in np.searchsorted with pytest-memtest?</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">time_bin_start</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">time_bin_start</span><span class="p">)</span>
                    <span class="n">time_bin_size</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_bin_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span>
                                     <span class="p">((</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bins</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">time_bin_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;time_bin_end&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
            <span class="k">elif</span> <span class="n">binsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_HAS_VAR_BINS</span><span class="p">:</span>
                    <span class="n">time_bin_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[::</span><span class="n">binsize</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;`binsize` requires Astropy 5.0 to guarantee equal number of points; &#39;</span>
                        <span class="s1">&#39;will use estimated time lengths for bins.&#39;</span><span class="p">,</span> <span class="n">LightkurveWarning</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">time_bin_start</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">time_bin_start</span><span class="p">)</span>
                    <span class="n">time_bin_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">binsize</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">day</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time_bin_size</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_bin_size</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="n">time_bin_size</span> <span class="o">*=</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span>

        <span class="c1"># Call AstroPy&#39;s aggregate_downsample</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="c1"># ignore uninteresting empty slice warnings</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">))</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">aggregate_downsample</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">time_bin_size</span><span class="o">=</span><span class="n">time_bin_size</span><span class="p">,</span>
                <span class="n">n_bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span>
                <span class="n">time_bin_start</span><span class="o">=</span><span class="n">time_bin_start</span><span class="p">,</span>
                <span class="n">aggregate_func</span><span class="o">=</span><span class="n">aggregate_func</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>

            <span class="c1"># If `flux_err` is populated, assume the errors combine as the root-mean-square</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">)):</span>
                <span class="n">rmse_func</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="p">)</span>
                <span class="n">ts_err</span> <span class="o">=</span> <span class="n">aggregate_downsample</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">time_bin_size</span><span class="o">=</span><span class="n">time_bin_size</span><span class="p">,</span>
                    <span class="n">n_bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span>
                    <span class="n">time_bin_start</span><span class="o">=</span><span class="n">time_bin_start</span><span class="p">,</span>
                    <span class="n">aggregate_func</span><span class="o">=</span><span class="n">rmse_func</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">ts</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts_err</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span>
            <span class="c1"># If `flux_err` is unavailable, populate `flux_err` as nanstd(flux)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ts_err</span> <span class="o">=</span> <span class="n">aggregate_downsample</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">time_bin_size</span><span class="o">=</span><span class="n">time_bin_size</span><span class="p">,</span>
                    <span class="n">n_bins</span><span class="o">=</span><span class="n">n_bins</span><span class="p">,</span>
                    <span class="n">time_bin_start</span><span class="o">=</span><span class="n">time_bin_start</span><span class="p">,</span>
                    <span class="n">aggregate_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">ts</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts_err</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span>

        <span class="c1"># Prepare a LightCurve object by ensuring there is a time column</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">_required_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">time_bin_start</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">time_bin_size</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure the required columns appear in the correct order</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">colname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_required_columns</span><span class="p">):</span>
            <span class="n">tmpcol</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">colname</span><span class="p">]</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">remove_column</span><span class="p">(</span><span class="n">colname</span><span class="p">)</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">tmpcol</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">colname</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.estimate_cdpp"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.estimate_cdpp.html#lightkurve.LightCurve.estimate_cdpp">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_cdpp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">transit_duration</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span> <span class="n">savgol_window</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">savgol_polyorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">5.0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate the CDPP noise metric using the Savitzky-Golay (SG) method.</span>

<span class="sd">        A common estimate of the noise in a lightcurve is the scatter that</span>
<span class="sd">        remains after all long term trends have been removed. This is the idea</span>
<span class="sd">        behind the Combined Differential Photometric Precision (CDPP) metric.</span>
<span class="sd">        The official Kepler Pipeline computes this metric using a wavelet-based</span>
<span class="sd">        algorithm to calculate the signal-to-noise of the specific waveform of</span>
<span class="sd">        transits of various durations. In this implementation, we use the</span>
<span class="sd">        simpler &quot;sgCDPP proxy algorithm&quot; discussed by Gilliland et al</span>
<span class="sd">        (2011ApJS..197....6G) and Van Cleve et al (2016PASP..128g5002V).</span>

<span class="sd">        The steps of this algorithm are:</span>
<span class="sd">            1. Remove low frequency signals using a Savitzky-Golay filter with</span>
<span class="sd">               window length `savgol_window` and polynomial order `savgol_polyorder`.</span>
<span class="sd">            2. Remove outliers by rejecting data points which are separated from</span>
<span class="sd">               the mean by `sigma` times the standard deviation.</span>
<span class="sd">            3. Compute the standard deviation of a running mean with</span>
<span class="sd">               a configurable window length equal to `transit_duration`.</span>

<span class="sd">        We use a running mean (as opposed to block averaging) to strongly</span>
<span class="sd">        attenuate the signal above 1/transit_duration whilst retaining</span>
<span class="sd">        the original frequency sampling.  Block averaging would set the Nyquist</span>
<span class="sd">        limit to 1/transit_duration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transit_duration : int, optional</span>
<span class="sd">            The transit duration in units of number of cadences. This is the</span>
<span class="sd">            length of the window used to compute the running mean. The default</span>
<span class="sd">            is 13, which corresponds to a 6.5 hour transit in data sampled at</span>
<span class="sd">            30-min cadence.</span>
<span class="sd">        savgol_window : int, optional</span>
<span class="sd">            Width of Savitsky-Golay filter in cadences (odd number).</span>
<span class="sd">            Default value 101 (2.0 days in Kepler Long Cadence mode).</span>
<span class="sd">        savgol_polyorder : int, optional</span>
<span class="sd">            Polynomial order of the Savitsky-Golay filter.</span>
<span class="sd">            The recommended value is 2.</span>
<span class="sd">        sigma : float, optional</span>
<span class="sd">            The number of standard deviations to use for clipping outliers.</span>
<span class="sd">            The default is 5.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cdpp : float</span>
<span class="sd">            Savitzky-Golay CDPP noise metric in units parts-per-million (ppm).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This implementation is adapted from the Matlab version used by</span>
<span class="sd">        Jeff van Cleve but lacks the normalization factor used there:</span>
<span class="sd">        svn+ssh://murzim/repo/so/trunk/Develop/jvc/common/compute_SG_noise.m</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transit_duration</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;transit_duration must be an integer in units &quot;</span>
                <span class="s2">&quot;number of cadences, got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transit_duration</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">detrended_lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span>
            <span class="n">window_length</span><span class="o">=</span><span class="n">savgol_window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">savgol_polyorder</span>
        <span class="p">)</span>
        <span class="n">cleaned_lc</span> <span class="o">=</span> <span class="n">detrended_lc</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>  <span class="c1"># ignore &quot;already normalized&quot; message</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;.*already.*&quot;</span><span class="p">)</span>
            <span class="n">normalized_lc</span> <span class="o">=</span> <span class="n">cleaned_lc</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s2">&quot;ppm&quot;</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">running_mean</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">normalized_lc</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="n">transit_duration</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.query_solar_system_objects"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.query_solar_system_objects.html#lightkurve.LightCurve.query_solar_system_objects">[docs]</a>    <span class="k">def</span> <span class="nf">query_solar_system_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cadence_mask</span><span class="o">=</span><span class="s2">&quot;outliers&quot;</span><span class="p">,</span>
        <span class="n">radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of asteroids or comets which affected the light curve.</span>

<span class="sd">        Light curves of stars or galaxies are frequently affected by solar</span>
<span class="sd">        system bodies (e.g. asteroids, comets, planets).  These objects can move</span>
<span class="sd">        across a target&#39;s photometric aperture mask on time scales of hours to</span>
<span class="sd">        days.  When they pass through a mask, they tend to cause a brief spike</span>
<span class="sd">        in the brightness of the target.  They can also cause dips by moving</span>
<span class="sd">        through a local background aperture mask (if any is used).</span>

<span class="sd">        The artifical spikes and dips introduced by asteroids are frequently</span>
<span class="sd">        confused with stellar flares, planet transits, etc.  This method helps</span>
<span class="sd">        to identify false signals injects by asteroids by providing a list of</span>
<span class="sd">        the solar system objects (name, brightness, time) that passed in the</span>
<span class="sd">        vicinity of the target during the span of the light curve.</span>

<span class="sd">        This method queries the `SkyBot API &lt;http://vo.imcce.fr/webservices/skybot/&gt;`_,</span>
<span class="sd">        which returns a list of asteroids/comets/planets given a location, time,</span>
<span class="sd">        and search cone.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * This method will use the `ra` and `dec` properties of the `LightCurve`</span>
<span class="sd">          object to determine the position of the search cone.</span>
<span class="sd">        * The size of the search cone is 15 spacecraft pixels by default. You</span>
<span class="sd">          can change this by passing the `radius` parameter (unit: degrees).</span>
<span class="sd">        * By default, this method will only search points in time during which the light</span>
<span class="sd">          curve showed 3-sigma outliers in flux. You can override this behavior</span>
<span class="sd">          and search for specific times by passing `cadence_mask`. See examples for details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cadence_mask : str, or boolean array with length of self.time</span>
<span class="sd">            mask in time to select which frames or points should be searched for SSOs.</span>
<span class="sd">            Default &quot;outliers&quot; will search for SSOs at points that are `sigma` from the mean.</span>
<span class="sd">            &quot;all&quot; will search all cadences. Alternatively, pass a boolean array with values of &quot;True&quot;</span>
<span class="sd">            for times to search for SSOs.</span>
<span class="sd">        radius : optional, float</span>
<span class="sd">            Radius in degrees to search for bodies. If None, will search for</span>
<span class="sd">            SSOs within 15 pixels.</span>
<span class="sd">        sigma : optional, float</span>
<span class="sd">            If `cadence_mask` is set to `&quot;outlier&quot;`, `sigma` will be used to identify</span>
<span class="sd">            outliers.</span>
<span class="sd">        location : optional, str</span>
<span class="sd">            Spacecraft location. Options include `&#39;kepler&#39;` and `&#39;tess&#39;`. Default: `self.mission`</span>
<span class="sd">        cache : optional, bool</span>
<span class="sd">            If True will cache the search result in the astropy cache. Set to False</span>
<span class="sd">            to request the search again.</span>
<span class="sd">        return_mask: optional, bool</span>
<span class="sd">            If True will return a boolean mask in time alongside the result</span>
<span class="sd">        show_progress: optional, bool</span>
<span class="sd">            If True will display a progress bar during the download</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : `pandas.DataFrame`</span>
<span class="sd">            DataFrame object which lists the Solar System objects in frames</span>
<span class="sd">            that were identified to contain SSOs.  Returns `None` if no objects</span>
<span class="sd">            were found.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Find if there are SSOs affecting the lightcurve for the given time frame:</span>

<span class="sd">            &gt;&gt;&gt; df_sso = lc.query_solar_system_objects(cadence_mask=(lc.time.value &gt;= 2014.1) &amp; (lc.time.value &lt;= 2014.9))  # doctest: +SKIP</span>

<span class="sd">        Find if there are SSOs affecting the lightcurve for all times, but it will be much slower:</span>

<span class="sd">            &gt;&gt;&gt; df_sso = lc.query_solar_system_objects(cadence_mask=&#39;all&#39;)  # doctest: +SKIP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">,</span> <span class="s2">&quot;dec&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input does not have a `</span><span class="si">{}</span><span class="s2">` attribute.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>

        <span class="c1"># Validate `cadence_mask`</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cadence_mask</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cadence_mask</span> <span class="o">==</span> <span class="s2">&quot;outliers&quot;</span><span class="p">:</span>
                <span class="n">cadence_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_outliers</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">return_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">cadence_mask</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">cadence_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid `cadence_mask` string argument&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cadence_mask</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
            <span class="n">cadence_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cadence_mask</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cadence_mask</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">)):</span>
            <span class="c1"># for boundary case of a single element tuple, e.g., (True)</span>
            <span class="n">cadence_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cadence_mask</span><span class="p">])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cadence_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the `cadence_mask` argument is missing or invalid&quot;</span><span class="p">)</span>
        <span class="c1"># Avoid searching times with NaN flux; this is necessary because e.g.</span>
        <span class="c1"># `remove_outliers` includes NaNs in its mask.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
            <span class="c1"># Temporary workaround for issue #1172. TODO: remove this `if`` statement</span>
            <span class="c1"># once we adopt AstroPy &gt;=5.0.3 as a minimum dependency</span>
            <span class="n">cadence_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unmasked</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cadence_mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>

        <span class="c1"># Validate `location`</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;mission&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mission</span><span class="p">:</span>
                <span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mission</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;you must pass a value for `location`.&quot;</span><span class="p">)</span>

        <span class="c1"># Validate `radius`</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># 15 pixels has been chosen as a reasonable default.</span>
            <span class="c1"># Comets have long tails which have tripped up users.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">location</span> <span class="o">==</span> <span class="s2">&quot;kepler&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">location</span> <span class="o">==</span> <span class="s2">&quot;k2&quot;</span><span class="p">):</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">arcsecond</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">location</span> <span class="o">==</span> <span class="s2">&quot;tess&quot;</span><span class="p">:</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="p">(</span><span class="mi">21</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">arcsecond</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="mi">15</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">arcsecond</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">_query_solar_system_objects</span><span class="p">(</span>
            <span class="n">ra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
            <span class="n">dec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
            <span class="n">times</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">jd</span><span class="p">[</span><span class="n">cadence_mask</span><span class="p">],</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span>
            <span class="n">show_progress</span><span class="o">=</span><span class="n">show_progress</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">jd</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">epoch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

    <span class="k">def</span> <span class="nf">_create_plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span>
        <span class="n">column</span><span class="o">=</span><span class="s2">&quot;flux&quot;</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">xlabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="s2">&quot;lightkurve&quot;</span><span class="p">,</span>
        <span class="n">show_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">colorbar_label</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">clip_outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implements `plot()`, `scatter()`, and `errorbar()` to avoid code duplication.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            One of &#39;plot&#39;, &#39;scatter&#39;, or &#39;errorbar&#39;.</span>
<span class="sd">        column : str</span>
<span class="sd">            Name of data column to plot. Default `flux`.</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            A matplotlib axes object to plot into. If no axes is provided,</span>
<span class="sd">            a new one will be generated.</span>
<span class="sd">        normalize : bool</span>
<span class="sd">            Normalize the lightcurve before plotting?</span>
<span class="sd">        xlabel : str</span>
<span class="sd">            X axis label.</span>
<span class="sd">        ylabel : str</span>
<span class="sd">            Y axis label.</span>
<span class="sd">        title : str</span>
<span class="sd">            Title shown at the top using matplotlib `set_title`.</span>
<span class="sd">        style : str</span>
<span class="sd">            Path or URL to a matplotlib style file, or name of one of</span>
<span class="sd">            matplotlib&#39;s built-in stylesheets (e.g. &#39;ggplot&#39;).</span>
<span class="sd">            Lightkurve&#39;s custom stylesheet is used by default.</span>
<span class="sd">        show_colorbar : boolean</span>
<span class="sd">            Show the colorbar if colors are given using the `c` argument?</span>
<span class="sd">        colorbar_label : str</span>
<span class="sd">            Label to show next to the colorbar (if `c` is given).</span>
<span class="sd">        offset : float</span>
<span class="sd">            Offset value to apply to the Y axis values before plotting. Use this</span>
<span class="sd">            to avoid light curves from overlapping on the same plot. By default,</span>
<span class="sd">            no offset is applied.</span>
<span class="sd">        clip_outliers : bool</span>
<span class="sd">            If ``True``, clip the y axis limit to the 95%-percentile range.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to Matplotlib&#39;s `plot`,</span>
<span class="sd">            `scatter`, or `errorbar` methods.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Configure the default style</span>
        <span class="k">if</span> <span class="n">style</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;lightkurve&quot;</span><span class="p">:</span>
            <span class="n">style</span> <span class="o">=</span> <span class="n">MPLSTYLE</span>
        <span class="c1"># Default xlabel</span>
        <span class="k">if</span> <span class="n">xlabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="s2">&quot;format&quot;</span><span class="p">):</span>
                <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Phase&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;bkjd&quot;</span><span class="p">:</span>
                <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Time - 2454833 [BKJD days]&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;btjd&quot;</span><span class="p">:</span>
                <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Time - 2457000 [BTJD days]&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;jd&quot;</span><span class="p">:</span>
                <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Time [JD]&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Time&quot;</span>

        <span class="c1"># Default ylabel</span>
        <span class="k">if</span> <span class="n">ylabel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;flux&quot;</span> <span class="o">==</span> <span class="n">column</span><span class="p">:</span>
                <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;Flux&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ylabel</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">normalize</span> <span class="ow">or</span> <span class="p">(</span><span class="n">column</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NORMALIZED&quot;</span><span class="p">)):</span>
                <span class="n">ylabel</span> <span class="o">=</span> <span class="s2">&quot;Normalized &quot;</span> <span class="o">+</span> <span class="n">ylabel</span>
            <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
                <span class="n">ylabel</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; [</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="s1">&#39;latex_inline&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>

        <span class="c1"># Default legend label</span>
        <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LABEL&quot;</span><span class="p">)</span>

        <span class="c1"># Workaround for AstroPy v5.0.0 issue #12481: the &#39;c&#39; argument</span>
        <span class="c1"># in matplotlib&#39;s scatter does not work with masked quantities.</span>
        <span class="k">if</span> <span class="s2">&quot;c&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unmasked</span>

        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flux_err</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">_err&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">flux_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Second workaround for AstroPy v5.0.0 issue #12481:</span>
        <span class="c1"># matplotlib does not work well with `MaskedNDArray` arrays.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">flux_err</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
            <span class="n">flux_err</span> <span class="o">=</span> <span class="n">flux_err</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Normalize the data if requested</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="c1"># ignore &quot;light curve is already normalized&quot; message because</span>
            <span class="c1"># the user explicitely asked for normalization here</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;.*already.*&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">column</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span><span class="p">:</span>
                    <span class="n">lc_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Code below is a temporary hack because `normalize()`</span>
                    <span class="c1"># does not have a `column` argument yet</span>
                    <span class="n">lc_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">lc_tmp</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux</span>
                    <span class="n">lc_tmp</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_err</span>
                    <span class="n">lc_normed</span> <span class="o">=</span> <span class="n">lc_tmp</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
                <span class="n">flux</span><span class="p">,</span> <span class="n">flux_err</span> <span class="o">=</span> <span class="n">lc_normed</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">lc_normed</span><span class="o">.</span><span class="n">flux_err</span>

        <span class="c1"># Apply offset if requested</span>
        <span class="k">if</span> <span class="n">offset</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">*</span> <span class="n">flux</span><span class="o">.</span><span class="n">unit</span>

        <span class="c1"># Make the plot</span>
        <span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">style</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;scatter&quot;</span><span class="p">:</span>
                <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">flux</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1"># Colorbars should only be plotted if the user specifies, and there is</span>
                <span class="c1"># a color specified that is not a string (e.g. &#39;C1&#39;) and is iterable.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">show_colorbar</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;c&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">))</span>
                    <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">colorbar_label</span><span class="p">)</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_tick_params</span><span class="p">(</span><span class="n">tick1On</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tick2On</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">minorticks_off</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;errorbar&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">flux_err</span><span class="p">)):</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
                        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">flux</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">flux_err</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column `</span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">` has no associated errors.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">flux</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
            <span class="c1"># Show the legend if labels were set</span>
            <span class="n">legend_labels</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">legend_labels</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">clip_outliers</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>
                <span class="n">margin</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span> <span class="o">-</span> <span class="n">margin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">+</span> <span class="n">margin</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="LightCurve.plot"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.plot.html#lightkurve.LightCurve.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the light curve using Matplotlib&#39;s `~matplotlib.pyplot.plot` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column : str</span>
<span class="sd">            Name of data column to plot. Default `flux`.</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            A matplotlib axes object to plot into. If no axes is provided,</span>
<span class="sd">            a new one will be generated.</span>
<span class="sd">        normalize : bool</span>
<span class="sd">            Normalize the lightcurve before plotting?</span>
<span class="sd">        xlabel : str</span>
<span class="sd">            X axis label.</span>
<span class="sd">        ylabel : str</span>
<span class="sd">            Y axis label.</span>
<span class="sd">        title : str</span>
<span class="sd">            Title shown at the top using matplotlib `set_title`.</span>
<span class="sd">        style : str</span>
<span class="sd">            Path or URL to a matplotlib style file, or name of one of</span>
<span class="sd">            matplotlib&#39;s built-in stylesheets (e.g. &#39;ggplot&#39;).</span>
<span class="sd">            Lightkurve&#39;s custom stylesheet is used by default.</span>
<span class="sd">        show_colorbar : boolean</span>
<span class="sd">            Show the colorbar if colors are given using the `c` argument?</span>
<span class="sd">        colorbar_label : str</span>
<span class="sd">            Label to show next to the colorbar (if `c` is given).</span>
<span class="sd">        offset : float</span>
<span class="sd">            Offset value to apply to the Y axis values before plotting. Use this</span>
<span class="sd">            to avoid light curves from overlapping on the same plot. By default,</span>
<span class="sd">            no offset is applied.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `matplotlib.pyplot.plot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_plot</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.scatter"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.scatter.html#lightkurve.LightCurve.scatter">[docs]</a>    <span class="k">def</span> <span class="nf">scatter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">colorbar_label</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">show_colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the light curve using Matplotlib&#39;s `~matplotlib.pyplot.scatter` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column : str</span>
<span class="sd">            Name of data column to plot. Default `flux`.</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            A matplotlib axes object to plot into. If no axes is provided,</span>
<span class="sd">            a new one will be generated.</span>
<span class="sd">        normalize : bool</span>
<span class="sd">            Normalize the lightcurve before plotting?</span>
<span class="sd">        xlabel : str</span>
<span class="sd">            X axis label.</span>
<span class="sd">        ylabel : str</span>
<span class="sd">            Y axis label.</span>
<span class="sd">        title : str</span>
<span class="sd">            Title shown at the top using matplotlib `set_title`.</span>
<span class="sd">        style : str</span>
<span class="sd">            Path or URL to a matplotlib style file, or name of one of</span>
<span class="sd">            matplotlib&#39;s built-in stylesheets (e.g. &#39;ggplot&#39;).</span>
<span class="sd">            Lightkurve&#39;s custom stylesheet is used by default.</span>
<span class="sd">        show_colorbar : boolean</span>
<span class="sd">            Show the colorbar if colors are given using the `c` argument?</span>
<span class="sd">        colorbar_label : str</span>
<span class="sd">            Label to show next to the colorbar (if `c` is given).</span>
<span class="sd">        offset : float</span>
<span class="sd">            Offset value to apply to the Y axis values before plotting. Use this</span>
<span class="sd">            to avoid light curves from overlapping on the same plot. By default,</span>
<span class="sd">            no offset is applied.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `matplotlib.pyplot.scatter`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_plot</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;scatter&quot;</span><span class="p">,</span>
            <span class="n">colorbar_label</span><span class="o">=</span><span class="n">colorbar_label</span><span class="p">,</span>
            <span class="n">show_colorbar</span><span class="o">=</span><span class="n">show_colorbar</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.errorbar"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.errorbar.html#lightkurve.LightCurve.errorbar">[docs]</a>    <span class="k">def</span> <span class="nf">errorbar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plots the light curve using Matplotlib&#39;s `~matplotlib.pyplot.errorbar` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        linestyle : str</span>
<span class="sd">            Connect the error bars using a line?</span>
<span class="sd">        column : str</span>
<span class="sd">            Name of data column to plot. Default `flux`.</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            A matplotlib axes object to plot into. If no axes is provided,</span>
<span class="sd">            a new one will be generated.</span>
<span class="sd">        normalize : bool</span>
<span class="sd">            Normalize the lightcurve before plotting?</span>
<span class="sd">        xlabel : str</span>
<span class="sd">            X axis label.</span>
<span class="sd">        ylabel : str</span>
<span class="sd">            Y axis label.</span>
<span class="sd">        title : str</span>
<span class="sd">            Title shown at the top using matplotlib `set_title`.</span>
<span class="sd">        style : str</span>
<span class="sd">            Path or URL to a matplotlib style file, or name of one of</span>
<span class="sd">            matplotlib&#39;s built-in stylesheets (e.g. &#39;ggplot&#39;).</span>
<span class="sd">            Lightkurve&#39;s custom stylesheet is used by default.</span>
<span class="sd">        show_colorbar : boolean</span>
<span class="sd">            Show the colorbar if colors are given using the `c` argument?</span>
<span class="sd">        colorbar_label : str</span>
<span class="sd">            Label to show next to the colorbar (if `c` is given).</span>
<span class="sd">        offset : float</span>
<span class="sd">            Offset value to apply to the Y axis values before plotting. Use this</span>
<span class="sd">            to avoid light curves from overlapping on the same plot. By default,</span>
<span class="sd">            no offset is applied.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `matplotlib.pyplot.errorbar`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;ls&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;linestyle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">linestyle</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_plot</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;errorbar&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.interact_bls"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.interact_bls.html#lightkurve.LightCurve.interact_bls">[docs]</a>    <span class="k">def</span> <span class="nf">interact_bls</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">notebook_url</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minimum_period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maximum_period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display an interactive Jupyter Notebook widget to find planets.</span>

<span class="sd">        The Box Least Squares (BLS) periodogram is a statistical tool used</span>
<span class="sd">        for detecting transiting exoplanets and eclipsing binaries in</span>
<span class="sd">        light curves.  This method will display a Jupyter Notebook Widget</span>
<span class="sd">        which enables the BLS algorithm to be used interactively.</span>
<span class="sd">        Behind the scenes, the widget uses the AstroPy implementation of BLS [1]_.</span>

<span class="sd">        This feature only works inside an active Jupyter Notebook.</span>
<span class="sd">        It requires Bokeh v1.0 (or later). An error message will be shown</span>
<span class="sd">        if these dependencies are not available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        notebook_url: str</span>
<span class="sd">            Location of the Jupyter notebook page (default: &quot;localhost:8888&quot;)</span>
<span class="sd">            When showing Bokeh applications, the Bokeh server must be</span>
<span class="sd">            explicitly configured to allow connections originating from</span>
<span class="sd">            different URLs. This parameter defaults to the standard notebook</span>
<span class="sd">            host and port. If you are running on a different location, you</span>
<span class="sd">            will need to supply this value for the application to display</span>
<span class="sd">            properly. If no protocol is supplied in the URL, e.g. if it is</span>
<span class="sd">            of the form &quot;localhost:8888&quot;, then &quot;http&quot; will be used.</span>
<span class="sd">            For use with JupyterHub, set the environment variable LK_JUPYTERHUB_EXTERNAL_URL</span>
<span class="sd">            to the public hostname of your JupyterHub and notebook_url will</span>
<span class="sd">            be defined appropriately automatically.</span>
<span class="sd">        minimum_period : float or None</span>
<span class="sd">            Minimum period to assess the BLS to. If None, default value of 0.3 days</span>
<span class="sd">            will be used.</span>
<span class="sd">        maximum_period : float or None</span>
<span class="sd">            Maximum period to evaluate the BLS to. If None, the time coverage of the</span>
<span class="sd">            lightcurve / 2 will be used.</span>
<span class="sd">        resolution : int</span>
<span class="sd">            Number of points to use in the BLS panel. Lower this value for faster</span>
<span class="sd">            but less accurate performance. You can also vary this value using the</span>
<span class="sd">            widget&#39;s Resolution Slider.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Load the light curve for Kepler-10, remove long-term trends, and</span>
<span class="sd">        display the BLS tool as follows:</span>

<span class="sd">            &gt;&gt;&gt; import lightkurve as lk</span>
<span class="sd">            &gt;&gt;&gt; lc = lk.search_lightcurve(&#39;kepler-10&#39;, quarter=3).download()  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; lc = lc.normalize().flatten()  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; lc.interact_bls()  # doctest: +SKIP</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] https://docs.astropy.org/en/stable/timeseries/bls.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.interact_bls</span> <span class="kn">import</span> <span class="n">show_interact_widget</span>

        <span class="n">notebook_url</span> <span class="o">=</span> <span class="n">finalize_notebook_url</span><span class="p">(</span><span class="n">notebook_url</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">show_interact_widget</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">notebook_url</span><span class="o">=</span><span class="n">notebook_url</span><span class="p">,</span>
            <span class="n">minimum_period</span><span class="o">=</span><span class="n">minimum_period</span><span class="p">,</span>
            <span class="n">maximum_period</span><span class="o">=</span><span class="n">maximum_period</span><span class="p">,</span>
            <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.to_table"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.to_table.html#lightkurve.LightCurve.to_table">[docs]</a>    <span class="k">def</span> <span class="nf">to_table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Table</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span>
        <span class="s2">&quot;2.0&quot;</span><span class="p">,</span>
        <span class="n">message</span><span class="o">=</span><span class="s2">&quot;`to_timeseries()` has been deprecated. `LightCurve` is a &quot;</span>
        <span class="s2">&quot;sub-class of Astropy TimeSeries as of Lightkurve v2.0 &quot;</span>
        <span class="s2">&quot;and no longer needs to be converted.&quot;</span><span class="p">,</span>
        <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_timeseries</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new `LightCurve` from an AstroPy</span>
<span class="sd">        `~astropy.timeseries.TimeSeries` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ts : `~astropy.timeseries.TimeSeries`</span>
<span class="sd">            The AstroPy TimeSeries object.  The object must contain columns</span>
<span class="sd">            named &#39;time&#39;, &#39;flux&#39;, and &#39;flux_err&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LightCurve</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">ts</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="n">ts</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">],</span> <span class="n">flux_err</span><span class="o">=</span><span class="n">ts</span><span class="p">[</span><span class="s2">&quot;flux_err&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_stingray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a `stingray.Lightcurve` object.</span>

<span class="sd">        This feature requires `Stingray &lt;https://stingraysoftware.github.io/&gt;`_</span>
<span class="sd">        to be installed (e.g. ``pip install stingray``).  An `ImportError` will</span>
<span class="sd">        be raised if this package is not available.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lightcurve : `stingray.Lightcurve`</span>
<span class="sd">            An stingray Lightcurve object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">stingray</span> <span class="kn">import</span> <span class="n">Lightcurve</span> <span class="k">as</span> <span class="n">StingrayLightcurve</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;You need to install Stingray to use &quot;</span>
                <span class="s2">&quot;the LightCurve.to_stringray() method.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">StingrayLightcurve</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">counts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span>
            <span class="n">err</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
            <span class="n">input_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_stingray</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new `LightCurve` from a `stingray.Lightcurve`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lc : `stingray.Lightcurve`</span>
<span class="sd">            A stingray Lightcurve object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LightCurve</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">lc</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="n">lc</span><span class="o">.</span><span class="n">counts</span><span class="p">,</span> <span class="n">flux_err</span><span class="o">=</span><span class="n">lc</span><span class="o">.</span><span class="n">counts_err</span><span class="p">)</span>

<div class="viewcode-block" id="LightCurve.to_csv"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.to_csv.html#lightkurve.LightCurve.to_csv">[docs]</a>    <span class="k">def</span> <span class="nf">to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the light curve to a CSV file.</span>

<span class="sd">        This method will convert the light curve into the Comma-Separated Values</span>
<span class="sd">        (CSV) text format. By default this method will return the result as a</span>
<span class="sd">        string, but you can also write the string directly to disk by providing</span>
<span class="sd">        a file name or handle via the `path_or_buf` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : string or file handle</span>
<span class="sd">            File path or object. By default, the result is returned as a string.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to</span>
<span class="sd">            `astropy`&#39;s `~astropy.timeseries.TimeSeries.write`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        csv : str or None</span>
<span class="sd">            Returns a csv-formatted string if ``path_or_buf=None``.</span>
<span class="sd">            Returns `None` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">use_stringio</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">path_or_buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_stringio</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>

            <span class="n">path_or_buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;ascii.csv&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_stringio</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path_or_buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="LightCurve.to_pandas"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.to_pandas.html#lightkurve.LightCurve.to_pandas">[docs]</a>    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the light curve to a Pandas `~pandas.DataFrame` object.</span>

<span class="sd">        The data frame will be indexed by `time` using values corresponding</span>
<span class="sd">        to the light curve&#39;s time format.  This is different from the</span>
<span class="sd">        default behavior of `astropy`&#39;s `~astropy.timeseries.TimeSeries.to_pandas`,</span>
<span class="sd">        which converts time values into ISO timestamps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dataframe : `pandas.DataFrame`</span>
<span class="sd">            A data frame indexed by `time`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Default AstroPy behavior is to change the time column into ``np.datetime64``</span>
        <span class="c1"># We override it here because it confuses Kepler/TESS users who are used</span>
        <span class="c1"># to working in BTJD and BKJD rather than ISO timestamps.</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="LightCurve.to_excel"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.to_excel.html#lightkurve.LightCurve.to_excel">[docs]</a>    <span class="k">def</span> <span class="nf">to_excel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shorthand for `to_pandas().to_excel()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : string or file handle</span>
<span class="sd">            File path or object.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `to_pandas().to_excel(**kwargs)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">openpyxl</span>  <span class="c1"># optional dependency</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="s2">&quot;You need to install `openpyxl` to use this feature, e.g. use `pip install openpyxl`.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.to_periodogram"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.to_periodogram.html#lightkurve.LightCurve.to_periodogram">[docs]</a>    <span class="k">def</span> <span class="nf">to_periodogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;lombscargle&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the light curve to a `~lightkurve.periodogram.Periodogram`</span>
<span class="sd">        power spectrum object.</span>

<span class="sd">        This method will call either</span>
<span class="sd">        `LombScarglePeriodogram.from_lightcurve() &lt;lightkurve.periodogram.LombScarglePeriodogram.from_lightcurve&gt;` or</span>
<span class="sd">        `BoxLeastSquaresPeriodogram.from_lightcurve() &lt;lightkurve.periodogram.BoxLeastSquaresPeriodogram.from_lightcurve&gt;`,</span>
<span class="sd">        which in turn wrap `astropy`&#39;s `~astropy.timeseries.LombScargle` and `~astropy.timeseries.BoxLeastSquares`.</span>

<span class="sd">        Optional keywords accepted if ``method=&#39;lombscargle&#39;`` are:</span>
<span class="sd">        ``minimum_frequency``, ``maximum_frequency``, ``mininum_period``,</span>
<span class="sd">        ``maximum_period``, ``frequency``, ``period``, ``nterms``,</span>
<span class="sd">        ``nyquist_factor``, ``oversample_factor``, ``freq_unit``,</span>
<span class="sd">        ``normalization``, ``ls_method``.</span>

<span class="sd">        Optional keywords accepted if ``method=&#39;bls&#39;`` are</span>
<span class="sd">        ``minimum_period``, ``maximum_period``, ``period``,</span>
<span class="sd">        ``frequency_factor``, ``duration``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;lombscargle&#39;, &#39;boxleastsquares&#39;, &#39;ls&#39;, &#39;bls&#39;}</span>
<span class="sd">            Use the Lomb Scargle or Box Least Squares (BLS) method to</span>
<span class="sd">            extract the power spectrum. Defaults to ``&#39;lombscargle&#39;``.</span>
<span class="sd">            ``&#39;ls&#39;`` and ``&#39;bls&#39;`` are shorthands for ``&#39;lombscargle&#39;``</span>
<span class="sd">            and ``&#39;boxleastsquares&#39;``.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Keyword arguments passed to either</span>
<span class="sd">            `LombScarglePeriodogram &lt;lightkurve.periodogram.LombScarglePeriodogram.from_lightcurve&gt;` or</span>
<span class="sd">            `BoxLeastSquaresPeriodogram &lt;lightkurve.periodogram.BoxLeastSquaresPeriodogram.from_lightcurve&gt;`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Periodogram : `~lightkurve.periodogram.Periodogram` object</span>
<span class="sd">            The power spectrum object extracted from the light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">supported_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span> <span class="s2">&quot;bls&quot;</span><span class="p">,</span> <span class="s2">&quot;lombscargle&quot;</span><span class="p">,</span> <span class="s2">&quot;boxleastsquares&quot;</span><span class="p">]</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">validate_method</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">supported_methods</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bls&quot;</span><span class="p">,</span> <span class="s2">&quot;boxleastsquares&quot;</span><span class="p">]:</span>
            <span class="kn">from</span> <span class="nn">.periodogram</span> <span class="kn">import</span> <span class="n">BoxLeastSquaresPeriodogram</span>

            <span class="k">return</span> <span class="n">BoxLeastSquaresPeriodogram</span><span class="o">.</span><span class="n">from_lightcurve</span><span class="p">(</span><span class="n">lc</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.periodogram</span> <span class="kn">import</span> <span class="n">LombScarglePeriodogram</span>

            <span class="k">return</span> <span class="n">LombScarglePeriodogram</span><span class="o">.</span><span class="n">from_lightcurve</span><span class="p">(</span><span class="n">lc</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.to_seismology"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.to_seismology.html#lightkurve.LightCurve.to_seismology">[docs]</a>    <span class="k">def</span> <span class="nf">to_seismology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a `~lightkurve.seismology.Seismology` object for estimating</span>
<span class="sd">        quick-look asteroseismic quantities.</span>

<span class="sd">        All `**kwargs` will be passed to the `to_periodogram()` method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        seismology : `~lightkurve.seismology.Seismology` object</span>
<span class="sd">            Object which can be used to estimate quick-look asteroseismic quantities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.seismology</span> <span class="kn">import</span> <span class="n">Seismology</span>

        <span class="k">return</span> <span class="n">Seismology</span><span class="o">.</span><span class="n">from_lightcurve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.to_fits"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.to_fits.html#lightkurve.LightCurve.to_fits">[docs]</a>    <span class="k">def</span> <span class="nf">to_fits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flux_column_name</span><span class="o">=</span><span class="s2">&quot;FLUX&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_data</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts the light curve to a FITS file in the Kepler/TESS file format.</span>

<span class="sd">        The FITS file will be returned as a `~astropy.io.fits.HDUList` object.</span>
<span class="sd">        If a `path` is specified then the file will also be written to disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str or None</span>
<span class="sd">            Location where the FITS file will be written, which is optional.</span>
<span class="sd">        overwrite : bool</span>
<span class="sd">            Whether or not to overwrite the file, if `path` is set.</span>
<span class="sd">        flux_column_name : str</span>
<span class="sd">            The column name in the FITS file where the light curve flux data</span>
<span class="sd">            should be stored.  Typical values are `FLUX` or `SAP_FLUX`.</span>
<span class="sd">        extra_data : dict</span>
<span class="sd">            Extra keywords or columns to include in the FITS file.</span>
<span class="sd">            Arguments of type str, int, float, or bool will be stored as</span>
<span class="sd">            keywords in the primary header.</span>
<span class="sd">            Arguments of type np.array or list will be stored as columns</span>
<span class="sd">            in the first extension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hdu : `~astropy.io.fits.HDUList`</span>
<span class="sd">            Returns an `~astropy.io.fits.HDUList` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typedir</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">int</span><span class="p">:</span> <span class="s2">&quot;J&quot;</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span>
            <span class="nb">float</span><span class="p">:</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span>
            <span class="nb">bool</span><span class="p">:</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span> <span class="s2">&quot;J&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">def</span> <span class="nf">_header_template</span><span class="p">(</span><span class="n">extension</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Returns a template `fits.Header` object for a given extension.&quot;&quot;&quot;</span>
            <span class="n">template_fn</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">PACKAGEDIR</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="s2">&quot;lc-ext</span><span class="si">{}</span><span class="s2">-header.txt&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fits</span><span class="o">.</span><span class="n">Header</span><span class="o">.</span><span class="n">fromtextfile</span><span class="p">(</span><span class="n">template_fn</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_make_primary_hdu</span><span class="p">(</span><span class="n">extra_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Returns the primary extension (#0).&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">extra_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extra_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">()</span>
            <span class="c1"># Copy the default keywords from a template file from the MAST archive</span>
            <span class="n">tmpl</span> <span class="o">=</span> <span class="n">_header_template</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">tmpl</span><span class="p">:</span>
                <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmpl</span><span class="p">[</span><span class="n">kw</span><span class="p">],</span> <span class="n">tmpl</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="n">kw</span><span class="p">])</span>

            <span class="c1"># Override the defaults where necessary</span>
            <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">__version__</span>

            <span class="n">default</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;ORIGIN&quot;</span><span class="p">:</span> <span class="s2">&quot;Unofficial data product&quot;</span><span class="p">,</span>
                <span class="s2">&quot;DATE&quot;</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">),</span>
                <span class="s2">&quot;CREATOR&quot;</span><span class="p">:</span> <span class="s2">&quot;lightkurve.LightCurve.to_fits()&quot;</span><span class="p">,</span>
                <span class="s2">&quot;PROCVER&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">__version__</span><span class="p">),</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">default</span><span class="p">:</span>
                <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">=</span> <span class="n">default</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">default</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Value for </span><span class="si">{}</span><span class="s2"> is None.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra_data</span><span class="p">[</span><span class="n">kw</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
                    <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">=</span> <span class="n">extra_data</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">extra_data</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Value for </span><span class="si">{}</span><span class="s2"> is None.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">hdu</span>

        <span class="k">def</span> <span class="nf">_make_lightcurve_extension</span><span class="p">(</span><span class="n">extra_data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Create the &#39;LIGHTCURVE&#39; extension (i.e. extension #1).&quot;&quot;&quot;</span>
            <span class="c1"># Turn the data arrays into fits columns and initialize the HDU</span>
            <span class="k">if</span> <span class="n">extra_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extra_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="s2">&quot;TIME&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;TIME&quot;</span><span class="p">,</span>
                        <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="p">,</span>
                        <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">,</span>
                        <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">flux_column_name</span> <span class="ow">in</span> <span class="n">k</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">flux_column_name</span><span class="p">,</span>
                        <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;E&quot;</span><span class="p">,</span>
                        <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
                        <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;flux_err&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="o">~</span><span class="p">(</span><span class="n">flux_column_name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;_ERR&quot;</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span>
                            <span class="n">name</span><span class="o">=</span><span class="n">flux_column_name</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;_ERR&quot;</span><span class="p">,</span>
                            <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;E&quot;</span><span class="p">,</span>
                            <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to_string</span><span class="p">(),</span>
                            <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;cadenceno&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                    <span class="p">[</span><span class="s2">&quot;CADENCENO&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;CADENCENO&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cadenceno</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra_data</span><span class="p">[</span><span class="n">kw</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span>
                            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span>
                            <span class="nb">format</span><span class="o">=</span><span class="n">typedir</span><span class="p">[</span><span class="n">extra_data</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">],</span>
                            <span class="n">array</span><span class="o">=</span><span class="n">extra_data</span><span class="p">[</span><span class="n">kw</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;SAP_QUALITY&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="p">:</span>
                <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">fits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;SAP_QUALITY&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="n">coldefs</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">ColDefs</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">coldefs</span><span class="p">)</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;EXTNAME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;LIGHTCURVE&quot;</span>
            <span class="k">return</span> <span class="n">hdu</span>

        <span class="k">def</span> <span class="nf">_hdulist</span><span class="p">(</span><span class="o">**</span><span class="n">extra_data</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Returns an astropy.io.fits.HDUList object.&quot;&quot;&quot;</span>
            <span class="n">list_out</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">_make_primary_hdu</span><span class="p">(</span><span class="n">extra_data</span><span class="o">=</span><span class="n">extra_data</span><span class="p">),</span>
                    <span class="n">_make_lightcurve_extension</span><span class="p">(</span><span class="n">extra_data</span><span class="o">=</span><span class="n">extra_data</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">list_out</span>

        <span class="n">hdu</span> <span class="o">=</span> <span class="n">_hdulist</span><span class="p">(</span><span class="o">**</span><span class="n">extra_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdu</span></div>

<div class="viewcode-block" id="LightCurve.to_corrector"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.to_corrector.html#lightkurve.LightCurve.to_corrector">[docs]</a>    <span class="k">def</span> <span class="nf">to_corrector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;sff&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a corrector object to remove instrument systematics.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        methods : string</span>
<span class="sd">            Currently, &quot;sff&quot; and &quot;cbv&quot; are supported.  This will return a</span>
<span class="sd">            `~correctors.SFFCorrector` and `~correctors.CBVCorrector`</span>
<span class="sd">            class instance respectively.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Extra keyword arguments to be passed to the corrector class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        correcter : `~correctors.corrector.Corrector`</span>
<span class="sd">            Instance of a Corrector class, which typically provides</span>
<span class="sd">            `~correctors.corrector.Corrector.correct()`</span>
<span class="sd">            and `~correctors.corrector.Corrector.diagnose()` methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pld&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;pld&#39; method can only be used on &quot;</span>
                <span class="s2">&quot;`TargetPixelFile` objects, not `LightCurve` objects.&quot;</span>
            <span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">validate_method</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">supported_methods</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sff&quot;</span><span class="p">,</span> <span class="s2">&quot;cbv&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sff&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.correctors</span> <span class="kn">import</span> <span class="n">SFFCorrector</span>

            <span class="k">return</span> <span class="n">SFFCorrector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;cbv&quot;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.correctors</span> <span class="kn">import</span> <span class="n">CBVCorrector</span>

            <span class="k">return</span> <span class="n">CBVCorrector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LightCurve.plot_river"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.plot_river.html#lightkurve.LightCurve.plot_river">[docs]</a>    <span class="nd">@deprecated_renamed_argument</span><span class="p">(</span>
        <span class="s2">&quot;t0&quot;</span><span class="p">,</span> <span class="s2">&quot;epoch_time&quot;</span><span class="p">,</span> <span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">warning_type</span><span class="o">=</span><span class="n">LightkurveDeprecationWarning</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_river</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">period</span><span class="p">,</span>
        <span class="n">epoch_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bin_points</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">minimum_phase</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">maximum_phase</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the light curve as a river plot.</span>

<span class="sd">        A river plot uses colors to represent the light curve values in</span>
<span class="sd">        chronological order, relative to the period of an interesting signal.</span>
<span class="sd">        Each row in the plot represents a full period cycle, and each column</span>
<span class="sd">        represents a fixed phase.  This type of plot is often used to visualize</span>
<span class="sd">        Transit Timing Variations (TTVs) in the light curves of exoplanets, but</span>
<span class="sd">        it can be used to visualize periodic signals of any origin.</span>

<span class="sd">        All extra keywords supplied are passed on to Matplotlib&#39;s</span>
<span class="sd">        `~matplotlib.pyplot.pcolormesh` function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        period: float</span>
<span class="sd">            Period at which to fold the light curve</span>
<span class="sd">        epoch_time : float</span>
<span class="sd">            Phase mid point for plotting. Defaults to the first time value.</span>
<span class="sd">        bin_points : int</span>
<span class="sd">            How many points should be in each bin.</span>
<span class="sd">        minimum_phase : float</span>
<span class="sd">            The minimum phase to plot.</span>
<span class="sd">        maximum_phase : float</span>
<span class="sd">            The maximum phase to plot.</span>
<span class="sd">        method : str</span>
<span class="sd">            The river method. Choose from `&#39;mean&#39;` or `&#39;median&#39;` or `&#39;sigma&#39;`.</span>
<span class="sd">            If `&#39;mean&#39;` or `&#39;median&#39;`, the plot will display the average value in each bin.</span>
<span class="sd">            If `&#39;sigma&#39;`, the plot will display the average in the bin divided by</span>
<span class="sd">            the error in each bin, in order to show the data in terms of standard</span>
<span class="sd">            deviation.</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed on to Matplotlib&#39;s</span>
<span class="sd">            `~matplotlib.pyplot.pcolormesh` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;time_original&quot;</span><span class="p">):</span>  <span class="c1"># folded light curve</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_original</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>

        <span class="c1"># epoch_time defaults to the first time value</span>
        <span class="k">if</span> <span class="n">epoch_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Lightkurve v1.x assumed that `period` was given in days if no unit</span>
        <span class="c1"># was specified.  We maintain this behavior for backwards-compatibility.</span>
        <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="n">period</span> <span class="o">*=</span> <span class="n">u</span><span class="o">.</span><span class="n">day</span>
        <span class="k">if</span> <span class="n">epoch_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epoch_time</span><span class="p">,</span> <span class="p">(</span><span class="n">Time</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">)):</span>
            <span class="n">epoch_time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">epoch_time</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">validate_method</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">supported_methods</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bin_points</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]):</span>
            <span class="n">bin_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">bin_points</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]):</span>
            <span class="n">bin_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
            <span class="n">bin_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">e</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
            <span class="n">bin_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">e</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span>
            <span class="n">bin_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">e</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_err</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="n">med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">/=</span> <span class="n">med</span>
        <span class="n">y</span> <span class="o">/=</span> <span class="n">med</span>

        <span class="c1"># Here `ph` is the phase of each time point x</span>
        <span class="c1"># cyc is the number of cycles that have occured at each time point x</span>
        <span class="c1"># since the phase 0 before x[0]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">period</span><span class="o">.</span><span class="n">value</span>
            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">maximum_phase</span> <span class="o">-</span> <span class="n">minimum_phase</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">bin_points</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bin_points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maximum_phase</span> <span class="o">-</span> <span class="n">minimum_phase</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                <span class="mi">2</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">period</span><span class="o">.</span><span class="n">value</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;`bin_points` is too high to plot a phase curve, resetting to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">bin_points</span>
                <span class="p">),</span>
                <span class="n">LightkurveWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">1</span>
        <span class="n">cyc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span> <span class="o">%</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">cyc</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span>

        <span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">epoch_time</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">/</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">phase</span> <span class="o">*</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span><span class="p">))</span> <span class="o">/</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1</span>
        <span class="n">cyc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">phase</span> <span class="o">*</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">%</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span><span class="p">))</span> <span class="o">/</span> <span class="n">period</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span>
        <span class="p">)</span>
        <span class="n">cyc</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span>
        <span class="n">ph</span><span class="p">[</span><span class="n">ph</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ar</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">minimum_phase</span><span class="p">,</span> <span class="n">maximum_phase</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cycs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cyc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">ph_masks</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ph</span> <span class="o">&gt;</span> <span class="n">bs</span><span class="p">[</span><span class="n">jdx</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ph</span> <span class="o">&lt;=</span> <span class="n">bs</span><span class="p">[</span><span class="n">jdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">qual_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cyc1</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cyc</span><span class="p">):</span>
            <span class="n">cyc_mask</span> <span class="o">=</span> <span class="n">cyc</span> <span class="o">==</span> <span class="n">cyc1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cyc_mask</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">ph_mask</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ph_masks</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">cyc_mask</span> <span class="o">&amp;</span> <span class="n">ph_mask</span> <span class="o">&amp;</span> <span class="n">qual_mask</span><span class="p">):</span>
                    <span class="n">ar</span><span class="p">[</span><span class="n">jdx</span><span class="p">,</span> <span class="n">cyc1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ar</span><span class="p">[</span><span class="n">jdx</span><span class="p">,</span> <span class="n">cyc1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_func</span><span class="p">(</span>
                        <span class="n">y</span><span class="p">[</span><span class="n">cyc_mask</span> <span class="o">&amp;</span> <span class="n">ph_mask</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="n">cyc_mask</span> <span class="o">&amp;</span> <span class="n">ph_mask</span><span class="p">]</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If the method is average we need to denormalize the plot</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]:</span>
            <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">median</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">):</span>
                <span class="n">median</span> <span class="o">=</span> <span class="n">median</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">ar</span> <span class="o">*=</span> <span class="n">median</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="mi">95</span><span class="p">)),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;vmin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;vmax&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="s2">&quot;viridis&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cmap&quot;</span><span class="p">,</span> <span class="s2">&quot;coolwarm&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="n">MPLSTYLE</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">cyc</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">))</span>

            <span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span>
                <span class="n">bs</span><span class="p">,</span> <span class="n">cycs</span><span class="p">,</span> <span class="n">ar</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;[Normalized Flux]&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">:</span>
                        <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="s2">&quot;latex&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">bin_points</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;Flux </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;Average Flux in Bin </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sigma&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bin_points</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span>
                        <span class="s2">&quot;Flux in units of Standard Deviation &quot;</span>
                        <span class="sa">r</span><span class="s2">&quot;$(f - \overline</span><span class="si">{f}</span><span class="s2">)/(\sigma_f)$&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span>
                        <span class="s2">&quot;Average Flux in Bin in units of Standard Deviation &quot;</span>
                        <span class="sa">r</span><span class="s2">&quot;$(f - \overline</span><span class="si">{f}</span><span class="s2">)/(\sigma_f)$&quot;</span>
                    <span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Phase&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Cycle&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">cyc</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LABEL&quot;</span><span class="p">))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">cyc</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="o">/</span> <span class="mf">12.0</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">cyc</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">cyc</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">bs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">bs</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="LightCurve.create_transit_mask"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.create_transit_mask.html#lightkurve.LightCurve.create_transit_mask">[docs]</a>    <span class="k">def</span> <span class="nf">create_transit_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">transit_time</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a boolean array that is ``True`` during transits and</span>
<span class="sd">        ``False`` elsewhere.</span>

<span class="sd">        This method supports multi-planet systems by allowing ``period``,</span>
<span class="sd">        ``transit_time``, and ``duration`` to be array-like lists of parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        period : `~astropy.units.Quantity`, float, or array-like</span>
<span class="sd">            Period(s) of the transits.</span>
<span class="sd">        duration : `~astropy.units.Quantity`, float, or array-like</span>
<span class="sd">            Duration(s) of the transits.</span>
<span class="sd">        transit_time : `~astropy.time.Time`, float, or array-like</span>
<span class="sd">            Transit midpoint(s) of the transits.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        transit_mask : np.array of bool</span>
<span class="sd">            Mask that flags transits. Mask is ``True`` where there are transits.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        You can create a transit mask for a single-planet system as follows::</span>

<span class="sd">            &gt;&gt;&gt; import lightkurve as lk</span>
<span class="sd">            &gt;&gt;&gt; lc = lk.LightCurve({&#39;time&#39;: [1, 2, 3, 4, 5], &#39;flux&#39;: [1, 1, 1, 1, 1]})</span>
<span class="sd">            &gt;&gt;&gt; lc.create_transit_mask(transit_time=2., period=2., duration=0.1)</span>
<span class="sd">            array([False,  True, False,  True, False])</span>

<span class="sd">        The method accepts lists of parameters to support multi-planet systems::</span>

<span class="sd">            &gt;&gt;&gt; lc.create_transit_mask(transit_time=[2., 3.], period=[2., 10.], duration=[0.1, 0.1])</span>
<span class="sd">            array([False,  True,  True,  True, False])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert Quantity objects to floats in units &quot;day&quot;</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">_to_unitless_day</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">_to_unitless_day</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>

        <span class="c1"># If ``transit_time`` is a ``Quantity```, attempt converting it to a ``Time`` object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transit_time</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
            <span class="n">transit_time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">transit_time</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Ensure all parameters are 1D-arrays</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
        <span class="n">transit_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">transit_time</span><span class="p">)</span>

        <span class="c1"># Make sure all params have the same number of entries</span>
        <span class="n">n_planets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_planets</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="p">[</span><span class="n">duration</span><span class="p">,</span> <span class="n">transit_time</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;period, duration, and transit_time must have &quot;</span>
                <span class="s2">&quot;the same number of values.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize an empty cadence mask</span>
        <span class="n">in_transit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">in_transit</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Create the transit mask</span>
        <span class="k">for</span> <span class="n">per</span><span class="p">,</span> <span class="n">dur</span><span class="p">,</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">transit_time</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
                <span class="c1"># If a `Time` is passed, ensure it has the right format &amp; scale</span>
                <span class="n">tt</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="n">per</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">in_transit</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">tt</span> <span class="o">+</span> <span class="n">hp</span><span class="p">)</span> <span class="o">%</span> <span class="n">per</span> <span class="o">-</span> <span class="n">hp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dur</span>

        <span class="k">return</span> <span class="n">in_transit</span></div>

<div class="viewcode-block" id="LightCurve.search_neighbors"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.search_neighbors.html#lightkurve.LightCurve.search_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">search_neighbors</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3600.0</span><span class="p">,</span> <span class="o">**</span><span class="n">search_criteria</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Search the data archive at MAST for the most nearby light curves.</span>

<span class="sd">        By default, the 10 nearest neighbors located within 3600 arcseconds</span>
<span class="sd">        are returned. You can override these defaults by changing the `limit`</span>
<span class="sd">        and `radius` parameters.</span>

<span class="sd">        If the LightCurve object is a Kepler, K2, or TESS light curve,</span>
<span class="sd">        the default behavior of this method is to only return light curves</span>
<span class="sd">        obtained during the exact same quarter, campaign, or sector.</span>
<span class="sd">        This is useful to enable coeval light curves to be inspected for</span>
<span class="sd">        spurious noise signals in common between multiple neighboring targets.</span>
<span class="sd">        You can override this default behavior by passing a `mission`,</span>
<span class="sd">        `quarter`, `campaign`, or `sector` argument yourself.</span>

<span class="sd">        Please refer to the docstring of `search_lightcurve` for a complete</span>
<span class="sd">        list of search parameters accepted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        limit : int</span>
<span class="sd">            Maximum number of results to return.</span>
<span class="sd">        radius : float or `astropy.units.Quantity` object</span>
<span class="sd">            Conesearch radius.  If a float is given it will be assumed to be in</span>
<span class="sd">            units of arcseconds.</span>
<span class="sd">        **search_criteria : kwargs</span>
<span class="sd">            Extra criteria to be passed to `search_lightcurve`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : :class:`SearchResult` object</span>
<span class="sd">            Object detailing the neighbor light curves found, sorted by</span>
<span class="sd">            distance from the current light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Local import to avoid circular dependency</span>
        <span class="kn">from</span> <span class="nn">.search</span> <span class="kn">import</span> <span class="n">search_lightcurve</span>

        <span class="c1"># By default, only return results from the same sector/quarter/campaign</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;mission&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">search_criteria</span>
            <span class="ow">and</span> <span class="s2">&quot;sector&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">search_criteria</span>
            <span class="ow">and</span> <span class="s2">&quot;quarter&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">search_criteria</span>
            <span class="ow">and</span> <span class="s2">&quot;campaign&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">search_criteria</span>
        <span class="p">):</span>
            <span class="n">mission</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;MISSION&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mission</span> <span class="o">==</span> <span class="s2">&quot;TESS&quot;</span><span class="p">:</span>
                <span class="n">search_criteria</span><span class="p">[</span><span class="s2">&quot;sector&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sector</span>
            <span class="k">elif</span> <span class="n">mission</span> <span class="o">==</span> <span class="s2">&quot;Kepler&quot;</span><span class="p">:</span>
                <span class="n">search_criteria</span><span class="p">[</span><span class="s2">&quot;quarter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quarter</span>
            <span class="k">elif</span> <span class="n">mission</span> <span class="o">==</span> <span class="s2">&quot;K2&quot;</span><span class="p">:</span>
                <span class="n">search_criteria</span><span class="p">[</span><span class="s2">&quot;campaign&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">campaign</span>

        <span class="c1"># Note: we increase `limit` by one below to account for the fact that the</span>
        <span class="c1"># current light curve will be returned by the search operation</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Started searching for up to </span><span class="si">{</span><span class="n">limit</span><span class="si">}</span><span class="s2"> neighbors within </span><span class="si">{</span><span class="n">radius</span><span class="si">}</span><span class="s2"> arcseconds.&quot;</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">search_lightcurve</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">search_criteria</span>
        <span class="p">)</span>

        <span class="c1"># Filter by distance &gt; 0 to avoid returning the current light curve</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2"> neighbors.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="LightCurve.head"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.head.html#lightkurve.LightCurve.head">[docs]</a>    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the first n rows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of rows to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc : LightCurve</span>
<span class="sd">            Light curve containing the first n rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="LightCurve.tail"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.tail.html#lightkurve.LightCurve.tail">[docs]</a>    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the last n rows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of rows to return.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lc : LightCurve</span>
<span class="sd">            Light curve containing the last n rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span></div>

<div class="viewcode-block" id="LightCurve.truncate"><a class="viewcode-back" href="../../reference/api/lightkurve.LightCurve.truncate.html#lightkurve.LightCurve.truncate">[docs]</a>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Truncates the light curve before and after some time value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        before : float</span>
<span class="sd">            Truncate all rows before this time value.</span>
<span class="sd">        after : float</span>
<span class="sd">            Truncate all rows after this time value.</span>
<span class="sd">        column : str, optional</span>
<span class="sd">            The name of the column on which the truncation is based. Defaults to &#39;time&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        truncated_lc : LightCurve</span>
<span class="sd">            The truncated light curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_to_unitless</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">_to_unitless</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">before</span>
        <span class="k">if</span> <span class="n">after</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">_to_unitless</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">after</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="FoldedLightCurve"><a class="viewcode-back" href="../../reference/api/lightkurve.FoldedLightCurve.html#lightkurve.FoldedLightCurve">[docs]</a><span class="k">class</span> <span class="nc">FoldedLightCurve</span><span class="p">(</span><span class="n">LightCurve</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of `LightCurve` in which the ``time`` parameter represents phase values.</span>

<span class="sd">    Compared to the `~lightkurve.lightcurve.LightCurve` base class, this class</span>
<span class="sd">    has extra meta data entries (``period``, ``epoch_time``, ``epoch_phase``,</span>
<span class="sd">    ``wrap_phase``, ``normalize_phase``), an extra column (``time_original``),</span>
<span class="sd">    extra properties (``phase``, ``odd_mask``, ``even_mask``),</span>
<span class="sd">    and implements different plotting defaults.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for `LightCurve.time`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The cycle of the correspond `time_original`.</span>
<span class="sd">        The first cycle is cycle 0, irrespective of whether it is a complete one or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epoch_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;EPOCH_TIME&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">epoch_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># explicit check needed (cannot be the default value in get() function call above)</span>
            <span class="c1"># because Lightcurve.fold() will put an explicit None in meta, if epoch_time is not specified.</span>
            <span class="n">epoch_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">cycle_epoch_start</span> <span class="o">=</span> <span class="n">epoch_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">time_original</span> <span class="o">-</span> <span class="n">cycle_epoch_start</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">-</span> <span class="n">result</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">odd_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Boolean mask which flags the odd-numbered cycles (1, 3, 5, etc).</span>

<span class="sd">        This is useful for studying every second occurence of a signal.</span>
<span class="sd">        For example, in exoplanet searches, comparisons of odd and even transits</span>
<span class="sd">        can help confirm the planetary nature of a signal. Differences in the</span>
<span class="sd">        depth, duration, or shape of the odd- and even-numbered transits would</span>
<span class="sd">        indicate that the &#39;transits&#39; are being caused by a near-equal mass</span>
<span class="sd">        eclipsing background binary, rather than a true transiting exoplanet.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        You can can visualize the odd- and even-centered transits separately as</span>
<span class="sd">        follows:</span>

<span class="sd">            &gt;&gt;&gt; f = lc.fold(...)  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; f[f.odd_mask].scatter()  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; f[f.even_mask].scatter()  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycle</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">even_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Boolean mask which flags the even-numbered cycles (2, 4, 6, etc).</span>

<span class="sd">        See the documentation of `odd_mask` for examples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">odd_mask</span>

    <span class="k">def</span> <span class="nf">_set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for plot, scatter, and errorbar.</span>
<span class="sd">        Ensures the xlabel is correctly set for folded light curves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;xlabel&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;xlabel&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Phase&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">TimeDelta</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;xlabel&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">return</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="FoldedLightCurve.plot"><a class="viewcode-back" href="../../reference/api/lightkurve.FoldedLightCurve.plot.html#lightkurve.FoldedLightCurve.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the folded light curve using matplotlib&#39;s</span>
<span class="sd">        `~matplotlib.pyplot.plot` method.</span>

<span class="sd">        See `LightCurve.plot` for details on the accepted arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `LightCurve.plot`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_xlabel</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">FoldedLightCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="FoldedLightCurve.scatter"><a class="viewcode-back" href="../../reference/api/lightkurve.FoldedLightCurve.scatter.html#lightkurve.FoldedLightCurve.scatter">[docs]</a>    <span class="k">def</span> <span class="nf">scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the folded light curve using matplotlib&#39;s `~matplotlib.pyplot.scatter` method.</span>

<span class="sd">        See `LightCurve.scatter` for details on the accepted arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `LightCurve.scatter`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_xlabel</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">FoldedLightCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="FoldedLightCurve.errorbar"><a class="viewcode-back" href="../../reference/api/lightkurve.FoldedLightCurve.errorbar.html#lightkurve.FoldedLightCurve.errorbar">[docs]</a>    <span class="k">def</span> <span class="nf">errorbar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the folded light curve using matplotlib&#39;s</span>
<span class="sd">        `~matplotlib.pyplot.errorbar` method.</span>

<span class="sd">        See `LightCurve.scatter` for details on the accepted arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `LightCurve.scatter`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_xlabel</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">FoldedLightCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="FoldedLightCurve.plot_river"><a class="viewcode-back" href="../../reference/api/lightkurve.FoldedLightCurve.plot_river.html#lightkurve.FoldedLightCurve.plot_river">[docs]</a>    <span class="k">def</span> <span class="nf">plot_river</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the folded light curve in a river style.</span>

<span class="sd">        See `~LightCurve.plot_river` for details on the accepted arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : dict</span>
<span class="sd">            Dictionary of arguments to be passed to `~LightCurve.plot_river`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : `~matplotlib.axes.Axes`</span>
<span class="sd">            The matplotlib axes object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FoldedLightCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">plot_river</span><span class="p">(</span>
            <span class="n">period</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">epoch_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch_time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div></div>


<span class="k">class</span> <span class="nc">KeplerLightCurve</span><span class="p">(</span><span class="n">LightCurve</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`LightCurve &lt;lightkurve.lightcurve.LightCurve&gt;`</span>
<span class="sd">    to represent data from NASA&#39;s Kepler and K2 mission.&quot;&quot;&quot;</span>

    <span class="n">_deprecated_keywords</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;targetid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time_format&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time_scale&quot;</span><span class="p">,</span>
        <span class="s2">&quot;flux_unit&quot;</span><span class="p">,</span>
        <span class="s2">&quot;quality_bitmask&quot;</span><span class="p">,</span>
        <span class="s2">&quot;channel&quot;</span><span class="p">,</span>
        <span class="s2">&quot;campaign&quot;</span><span class="p">,</span>
        <span class="s2">&quot;quarter&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mission&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ra&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dec&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">_default_time_format</span> <span class="o">=</span> <span class="s2">&quot;bkjd&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a `KeplerLightCurve` by reading the given file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Local path or remote url of a Kepler light curve FITS file.</span>
<span class="sd">        flux_column : str, optional</span>
<span class="sd">            The column in the FITS file to be read as `flux`. Defaults to &#39;pdcsap_flux&#39;.</span>
<span class="sd">            Typically &#39;pdcsap_flux&#39; or &#39;sap_flux&#39;.</span>
<span class="sd">        quality_bitmask : str or int, optional</span>
<span class="sd">            Bitmask (integer) which identifies the quality flag bitmask that should</span>
<span class="sd">            be used to mask out bad cadences. If a string is passed, it has the</span>
<span class="sd">            following meaning:</span>

<span class="sd">                * &quot;none&quot;: no cadences will be ignored</span>
<span class="sd">                * &quot;default&quot;: cadences with severe quality issues will be ignored</span>
<span class="sd">                * &quot;hard&quot;: more conservative choice of flags to ignore</span>
<span class="sd">                  This is known to remove good data.</span>
<span class="sd">                * &quot;hardest&quot;: removes all data that has been flagged</span>
<span class="sd">                  This mask is not recommended.</span>

<span class="sd">            See the :class:`KeplerQualityFlags &lt;lightkurve.utils.KeplerQualityFlags&gt;` class for details on the bitmasks.</span>
<span class="sd">        format : str, optional</span>
<span class="sd">            The format of the Kepler FITS file. Should be one of &#39;kepler&#39;, &#39;k2sff&#39;, &#39;everest&#39;. Defaults to &#39;kepler&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default to Kepler file format</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;kepler&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_fits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">flux_column_name</span><span class="o">=</span><span class="s2">&quot;FLUX&quot;</span><span class="p">,</span>
        <span class="n">aperture_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">extra_data</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the KeplerLightCurve to a FITS file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string, default None</span>
<span class="sd">            File path, if `None` returns an astropy.io.fits.HDUList object.</span>
<span class="sd">        overwrite : bool</span>
<span class="sd">            Whether or not to overwrite the file</span>
<span class="sd">        flux_column_name : str</span>
<span class="sd">            The name of the label for the FITS extension, e.g. SAP_FLUX or FLUX</span>
<span class="sd">        aperture_mask : array-like</span>
<span class="sd">            Optional 2D aperture mask to save with this lightcurve object, if</span>
<span class="sd">            defined.  The mask can be either a boolean mask or an integer mask</span>
<span class="sd">            mimicking the Kepler/TESS convention; boolean masks are</span>
<span class="sd">            automatically converted to the Kepler/TESS conventions</span>
<span class="sd">        extra_data : dict</span>
<span class="sd">            Extra keywords or columns to include in the FITS file.</span>
<span class="sd">            Arguments of type str, int, float, or bool will be stored as</span>
<span class="sd">            keywords in the primary header.</span>
<span class="sd">            Arguments of type np.array or list will be stored as columns</span>
<span class="sd">            in the first extension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hdu : astropy.io.fits</span>
<span class="sd">            Returns an astropy.io.fits object if path is None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kepler_specific_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;TELESCOP&quot;</span><span class="p">:</span> <span class="s2">&quot;KEPLER&quot;</span><span class="p">,</span>
            <span class="s2">&quot;INSTRUME&quot;</span><span class="p">:</span> <span class="s2">&quot;Kepler Photometer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;OBJECT&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetid</span><span class="p">),</span>
            <span class="s2">&quot;KEPLERID&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetid</span><span class="p">,</span>
            <span class="s2">&quot;CHANNEL&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
            <span class="s2">&quot;MISSION&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mission</span><span class="p">,</span>
            <span class="s2">&quot;RA_OBJ&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ra</span><span class="p">,</span>
            <span class="s2">&quot;DEC_OBJ&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dec</span><span class="p">,</span>
            <span class="s2">&quot;EQUINOX&quot;</span><span class="p">:</span> <span class="mi">2000</span><span class="p">,</span>
            <span class="s2">&quot;DATE-OBS&quot;</span><span class="p">:</span> <span class="n">Time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2454833.0</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;jd&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">isot</span><span class="p">,</span>
            <span class="s2">&quot;SAP_QUALITY&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">quality</span><span class="p">,</span>
            <span class="s2">&quot;MOM_CENTR1&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_col</span><span class="p">,</span>
            <span class="s2">&quot;MOM_CENTR2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_row</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kepler_specific_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">kw</span><span class="o">.</span><span class="n">lower</span> <span class="o">==</span> <span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">extra_data</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">kepler_specific_data</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">KeplerLightCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_fits</span><span class="p">(</span>
            <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_data</span>
        <span class="p">)</span>

        <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;QUARTER&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;QUARTER&quot;</span><span class="p">)</span>
        <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;CAMPAIGN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CAMPAIGN&quot;</span><span class="p">)</span>

        <span class="n">hdu</span> <span class="o">=</span> <span class="n">_make_aperture_extension</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">aperture_mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hdu</span>


<span class="k">class</span> <span class="nc">TessLightCurve</span><span class="p">(</span><span class="n">LightCurve</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subclass of :class:`LightCurve &lt;lightkurve.lightcurve.LightCurve&gt;`</span>
<span class="sd">    to represent data from NASA&#39;s TESS mission.&quot;&quot;&quot;</span>

    <span class="n">_deprecated_keywords</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;targetid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time_format&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time_scale&quot;</span><span class="p">,</span>
        <span class="s2">&quot;flux_unit&quot;</span><span class="p">,</span>
        <span class="s2">&quot;quality_bitmask&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sector&quot;</span><span class="p">,</span>
        <span class="s2">&quot;camera&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ccd&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mission&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ra&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dec&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">_default_time_format</span> <span class="o">=</span> <span class="s2">&quot;btjd&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a `TessLightCurve` by reading the given file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Local path or remote url of a TESS light curve FITS file.</span>
<span class="sd">        flux_column : str, optional</span>
<span class="sd">            The column in the FITS file to be read as `flux`. Defaults to &#39;pdcsap_flux&#39;.</span>
<span class="sd">            Typically &#39;pdcsap_flux&#39; or &#39;sap_flux&#39;.</span>
<span class="sd">        quality_bitmask : str or int, optional</span>
<span class="sd">            Bitmask (integer) which identifies the quality flag bitmask that should</span>
<span class="sd">            be used to mask out bad cadences. If a string is passed, it has the</span>
<span class="sd">            following meaning:</span>

<span class="sd">                * &quot;none&quot;: no cadences will be ignored</span>
<span class="sd">                * &quot;default&quot;: cadences with severe quality issues will be ignored</span>
<span class="sd">                * &quot;hard&quot;: more conservative choice of flags to ignore</span>
<span class="sd">                  This is known to remove good data.</span>
<span class="sd">                * &quot;hardest&quot;: removes all data that has been flagged</span>
<span class="sd">                  This mask is not recommended.</span>

<span class="sd">            See the :class:`TessQualityFlags &lt;lightkurve.utils.TessQualityFlags&gt;` class for details on the bitmasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default to TESS file format</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;tess&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_fits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">flux_column_name</span><span class="o">=</span><span class="s2">&quot;FLUX&quot;</span><span class="p">,</span>
        <span class="n">aperture_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">extra_data</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the KeplerLightCurve to a FITS file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string, default None</span>
<span class="sd">            File path, if `None` returns an astropy.io.fits.HDUList object.</span>
<span class="sd">        overwrite : bool</span>
<span class="sd">            Whether or not to overwrite the file</span>
<span class="sd">        flux_column_name : str</span>
<span class="sd">            The name of the label for the FITS extension, e.g. SAP_FLUX or FLUX</span>
<span class="sd">        aperture_mask : array-like</span>
<span class="sd">            Optional 2D aperture mask to save with this lightcurve object, if</span>
<span class="sd">            defined.  The mask can be either a boolean mask or an integer mask</span>
<span class="sd">            mimicking the Kepler/TESS convention; boolean masks are</span>
<span class="sd">            automatically converted to the Kepler/TESS conventions</span>
<span class="sd">        extra_data : dict</span>
<span class="sd">            Extra keywords or columns to include in the FITS file.</span>
<span class="sd">            Arguments of type str, int, float, or bool will be stored as</span>
<span class="sd">            keywords in the primary header.</span>
<span class="sd">            Arguments of type np.array or list will be stored as columns</span>
<span class="sd">            in the first extension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hdu : astropy.io.fits</span>
<span class="sd">            Returns an astropy.io.fits object if path is None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tess_specific_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;OBJECT&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetid</span><span class="p">),</span>
            <span class="s2">&quot;MISSION&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;MISSION&quot;</span><span class="p">),</span>
            <span class="s2">&quot;RA_OBJ&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;RA&quot;</span><span class="p">),</span>
            <span class="s2">&quot;TELESCOP&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;MISSION&quot;</span><span class="p">),</span>
            <span class="s2">&quot;CAMERA&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CAMERA&quot;</span><span class="p">),</span>
            <span class="s2">&quot;CCD&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;CCD&quot;</span><span class="p">),</span>
            <span class="s2">&quot;SECTOR&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SECTOR&quot;</span><span class="p">),</span>
            <span class="s2">&quot;TARGETID&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TARGETID&quot;</span><span class="p">),</span>
            <span class="s2">&quot;DEC_OBJ&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DEC&quot;</span><span class="p">),</span>
            <span class="s2">&quot;MOM_CENTR1&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_col</span><span class="p">,</span>
            <span class="s2">&quot;MOM_CENTR2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">centroid_row</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">tess_specific_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">kw</span><span class="o">.</span><span class="n">lower</span> <span class="o">==</span> <span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">extra_data</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">extra_data</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span> <span class="o">=</span> <span class="n">tess_specific_data</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TessLightCurve</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_fits</span><span class="p">(</span>
            <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_data</span>
        <span class="p">)</span>

        <span class="c1"># We do this because the TESS file format is subtly different in the</span>
        <span class="c1">#    name of this column.</span>
        <span class="n">hdu</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">change_name</span><span class="p">(</span><span class="s2">&quot;SAP_QUALITY&quot;</span><span class="p">,</span> <span class="s2">&quot;QUALITY&quot;</span><span class="p">)</span>

        <span class="n">hdu</span> <span class="o">=</span> <span class="n">_make_aperture_extension</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">aperture_mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hdu</span>


<span class="c1"># Helper functions</span>


<span class="k">def</span> <span class="nf">_boolean_mask_to_bitmask</span><span class="p">(</span><span class="n">aperture_mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Takes in an aperture_mask and returns a Kepler-style bitmask</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    aperture_mask : array-like</span>
<span class="sd">        2D aperture mask. The mask can be either a boolean mask or an integer</span>
<span class="sd">        mask mimicking the Kepler/TESS convention; boolean or boolean-like masks</span>
<span class="sd">        are converted to the Kepler/TESS conventions.  Kepler bitmasks are</span>
<span class="sd">        returned unchanged except for possible datatype conversion.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bitmask : numpy uint8 array</span>
<span class="sd">        A bitmask incompletely mimicking the Kepler/TESS convention: Bit 2,</span>
<span class="sd">        value = 3, means &quot;pixel was part of the custom aperture&quot;.  The other</span>
<span class="sd">        bits have no meaning and are currently assigned a value of 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Masks can either be boolean input or Kepler pipeline style</span>
    <span class="n">clean_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">aperture_mask</span><span class="p">)</span>

    <span class="n">contains_bit2</span> <span class="o">=</span> <span class="p">(</span><span class="n">clean_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
    <span class="n">all_zeros_or_ones</span> <span class="o">=</span> <span class="p">(</span><span class="n">clean_mask</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;float&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
        <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">clean_mask</span><span class="p">))</span> <span class="o">-</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span> <span class="o">==</span> <span class="nb">set</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">is_bool_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">aperture_mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">all_zeros_or_ones</span>

    <span class="k">if</span> <span class="n">is_bool_mask</span><span class="p">:</span>
        <span class="n">out_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">aperture_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">out_mask</span><span class="p">[</span><span class="n">aperture_mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">out_mask</span> <span class="o">=</span> <span class="n">out_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">contains_bit2</span><span class="p">:</span>
        <span class="n">out_mask</span> <span class="o">=</span> <span class="n">aperture_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The input aperture mask must be boolean or follow the &quot;</span>
            <span class="s2">&quot;Kepler-pipeline standard; returning None.&quot;</span>
        <span class="p">)</span>
        <span class="n">out_mask</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">out_mask</span>


<span class="k">def</span> <span class="nf">_make_aperture_extension</span><span class="p">(</span><span class="n">hdu_list</span><span class="p">,</span> <span class="n">aperture_mask</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns an `ImageHDU` object containing the &#39;APERTURE&#39; extension</span>
<span class="sd">    of a light curve file.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">aperture_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bitmask</span> <span class="o">=</span> <span class="n">_boolean_mask_to_bitmask</span><span class="p">(</span><span class="n">aperture_mask</span><span class="p">)</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">fits</span><span class="o">.</span><span class="n">ImageHDU</span><span class="p">(</span><span class="n">bitmask</span><span class="p">)</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;EXTNAME&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;APERTURE&quot;</span>
        <span class="n">hdu_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hdu</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hdu_list</span>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright Lightkurve developers.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>